[
["objects-types-and-useful-r-functions-to-get-started.html", "Chapter 2 Objects, types and useful R functions to get started 2.1 The numeric class 2.2 The character class 2.3 The factor class 2.4 The Date class 2.5 The logical class 2.6 Vectors and matrices 2.7 The list class 2.8 The data.frame and tibble classes 2.9 Formulas 2.10 Models 2.11 NULL, NA and NaN 2.12 Exercises", " Chapter 2 Objects, types and useful R functions to get started All objects in R have a given type. You already know most of them, as these types are also used in mathematics. Integers, floating point numbers, or floats, matrices, etc, are all objects you are already familiar with. But R has other, maybe lesser known data types (that you can find in a lot of other programming languages) that you need to become familiar with. But first, we need to learn how to assign a value to a variable. This can be done in two ways: a &lt;- 3 or a = 3 in very practical terms, there is no difference between the two. I prefer using &lt;- for assigning values to varibles and reserve = for passing arguments to functions, for example: spam &lt;- mean(x = c(1,2,3)) I think this is less confusing than: spam = mean(x = c(1,2,3)) but as I explained above you can use whatever you feel most comfortable with. 2.1 The numeric class To define single numbers, you can do the following: a &lt;- 3 The class() function allows you to check the class of an object: class(a) ## [1] &quot;numeric&quot; Decimals are defined with the character .: a &lt;- 3.14 R also supports integers. If you find yourself in a situation where you explicitely need an integer and not a floating point number, you can use the following: a &lt;- as.integer(3) class(a) ## [1] &quot;integer&quot; The as.integer() function is very useful, because it converts its argument into an integer. There is a whole family of as.*() functions. To convert a into a floating point number again: class(as.numeric(a)) ## [1] &quot;numeric&quot; There is also is.numeric() which tests wether a number is of the numeric class: is.numeric(a) ## [1] TRUE These functions are very useful, there is one for any of the supported types in R. Later, we are going to learn about the {purrr} package, which is a very powerful package for functional programming. This package includes further such functions. 2.2 The character class Use \" \" to define characters (called strings in other programming languages): a &lt;- &quot;this is a string&quot; class(a) ## [1] &quot;character&quot; To convert something to a character you can use the as.character() function: a &lt;- 4.392 class(a) ## [1] &quot;numeric&quot; class(as.character(a)) ## [1] &quot;character&quot; It is also possible to convert a character to a numeric: a &lt;- &quot;4.392&quot; class(a) ## [1] &quot;character&quot; class(as.numeric(a)) ## [1] &quot;numeric&quot; But this only works if it makes sense: a &lt;- &quot;this won&#39;t work, chief&quot; class(a) ## [1] &quot;character&quot; as.numeric(a) ## Warning: NAs introduced by coercion ## [1] NA A very nice package to work with characters is {stringr}, which is also part of the {tidyverse}. 2.3 The factor class Factors look like characters, but are very different. They are the representation of categorical variables. A {tidyverse} package to work with factors is {forcats}. You would rarely use factor variables outside of datasets, so for now, it is enough to know that this class exists. We are going to learn more about factor variables in Chapter 4, by using the {forcats} package. 2.4 The Date class Dates also look like characters, but are very different too: as.Date(&quot;2019/03/19&quot;) ## [1] &quot;2019-03-19&quot; class(as.Date(&quot;2019/03/19&quot;)) ## [1] &quot;Date&quot; Manipulating dates and time can be tricky, but thankfully there’s a {tidyverse} package for that, called {lubridate}. We are going to go over this package in Chapter 4. 2.5 The logical class This class is the result of logical comparisons, for example, if you type: 4 &gt; 3 ## [1] TRUE R returns TRUE, which is an object of class logical: k &lt;- 4 &gt; 3 class(k) ## [1] &quot;logical&quot; In other programming languages, logicals are often called bools. A logical variable can only have two values, either TRUE or FALSE. You can test the truthiness of a variable with isTRUE(): k &lt;- 4 &gt; 3 isTRUE(k) ## [1] TRUE How can you test if a variable is false? There is not a isFALSE() function (at least not without having to load a package containing this function), but there is way to do it: k &lt;- 4 &gt; 3 !isTRUE(k) ## [1] FALSE The ! operator indicates negation, so the above expression could be translated as is k not TRUE?. There are other such operators, namely &amp;, &amp;&amp;, |, ||. &amp; means and and | stands for or. You might be wondering what the difference between &amp; and &amp;&amp; is? Or between | and ||? &amp; and | work on vector, doing pairwaise comparisons: one &lt;- c(TRUE, FALSE, TRUE, FALSE) two &lt;- c(FALSE, TRUE, TRUE, TRUE) one &amp; two ## [1] FALSE FALSE TRUE FALSE Compare this to the &amp;&amp; operator: one &lt;- c(TRUE, FALSE, TRUE, FALSE) two &lt;- c(FALSE, TRUE, TRUE, TRUE) one &amp;&amp; two ## [1] FALSE The &amp;&amp; and || operators only compare the first element of the vectors and stop as soon as a the return value can be safely determined. This is called short-circuiting. Consider the following: one &lt;- c(TRUE, FALSE, TRUE, FALSE) two &lt;- c(FALSE, TRUE, TRUE, TRUE) three &lt;- c(TRUE, TRUE, FALSE, FALSE) one &amp;&amp; two &amp;&amp; three ## [1] FALSE one || two || three ## [1] TRUE The || operator stops as soon it evaluates to TRUE whereas the &amp;&amp; stops as soon as it evaluates to FALSE. Personally, I rarely use || or &amp;&amp; because I get confused. I find using | or &amp; in combination with the all() or any() functions much more useful: one &lt;- c(TRUE, FALSE, TRUE, FALSE) two &lt;- c(FALSE, TRUE, TRUE, TRUE) any(one &amp; two) ## [1] TRUE all(one &amp; two) ## [1] FALSE any() checks whether any of the vector’s elements are TRUE and all() checks if all elements of the vector are TRUE. As a final note, you should know that is possible to use T for TRUE and F for FALSE but I would advise against doing this, because it is not very explicit. 2.6 Vectors and matrices You can create a vector in different ways. But first of all, it is important to understand that a vector in most programming languages is nothing more than a list of things. These things can be numbers (either integers or floats), strings, or even other vectors. A vector in R can only contain elements of one single type. This is not the case for a list, which is much more flexible. We will talk about lists shortly, but let’s first focus on vectors and matrices. 2.6.1 The c() function A very important function that allows you to build a vector is c(): a &lt;- c(1,2,3,4,5) This creates a vector with elements 1, 2, 3, 4, 5. If you check its class: class(a) ## [1] &quot;numeric&quot; This can be confusing: you where probably expecting a to be of class vector or something similar. This is not the case if you use c() to create the vector, because c() doesn’t build a vector in the mathematical sense, but a so-called atomic vector. Checking its dimension: dim(a) ## NULL returns NULL because an atomic vector doesn’t have a dimension. If you want to create a true vector, you need to use cbind() or rbind(). But before continuing, be aware that atomic vectors can only contain elements of the same type: c(1, 2, &quot;3&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; because “3” is a character, all the other values get implicitely converted to characters. You have to be very careful about this, and if you use atomic vectors in your programming, you have to make absolutely sure that no characters or booleans or whatever else are going to convert your atomic vector to something you were not expecting. 2.6.2 cbind() and rbind() You can create a true vector with cbind(): a &lt;- cbind(1,2,3,4,5) Check its class now: class(a) ## [1] &quot;matrix&quot; This is exactly what we expected. Let’s check its dimension: dim(a) ## [1] 1 5 This returns the dimension of a using the LICO notation (number of LInes first, the number of COlumns). It is also possible to bind vectors together to create a matrix. b &lt;- cbind(6,7,8,9,10) Now let’s put vector a and b into a matrix called matrix_c using rbind(). rbind() functions the same way as cbind() but glues the vectors together by rows and not by columns. matrix_c &lt;- rbind(a,b) print(matrix_c) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 2.6.3 The matrix class R also has support for matrices. For example, you can create a matrix of dimension (5,5) filled with 0’s with the matrix() function: matrix_a &lt;- matrix(0, nrow = 5, ncol = 5) If you want to create the following matrix: \\[ B = \\left( \\begin{array}{ccc} 2 &amp; 4 &amp; 3 \\\\ 1 &amp; 5 &amp; 7 \\end{array} \\right) \\] you would do it like this: B &lt;- matrix(c(2, 4, 3, 1, 5, 7), nrow = 2, byrow = TRUE) The option byrow = TRUE means that the rows of the matrix will be filled first. You can access individual elements of matrix_a like so: matrix_a[2, 3] ## [1] 0 and R returns its value, 0. We can assign a new value to this element if we want. Try: matrix_a[2, 3] &lt;- 7 and now take a look at matrix_a again. print(matrix_a) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 0 0 7 0 0 ## [3,] 0 0 0 0 0 ## [4,] 0 0 0 0 0 ## [5,] 0 0 0 0 0 Recall our vector b: b &lt;- cbind(6,7,8,9,10) To access its third element, you can simply write: b[3] ## [1] 8 I have heard many people praising R for being a matrix based language. Matrices are indeed useful, and statisticians are used to working with them. However, I very rarely use matrices in my day to day work, and prefer an approach based on data frames (which will be discussed below). This is because working with data frames makes it easier to use R’s advanced functional programming language capabilities, and this is where R really shines in my opinion. Working with matrices almost automatically implies using loops and all the iterative programming techniques, à la Fortran, which I personally believe are ill-suited for interactive statistical programming (as discussed in the introduction). 2.7 The list class The list class is a very flexible class, and thus, very useful. You can put anything inside a list, such as numbers: list1 &lt;- list(3, 2) or other lists constructed with c(): list2 &lt;- list(c(1, 2), c(3, 4)) you can also put objects of different classes in the same list: list3 &lt;- list(3, c(1, 2), &quot;lists are amazing!&quot;) and of course create list of lists: my_lists &lt;- list(list1, list2, list3) To check the contents of a list, you can use the structure function str(): str(my_lists) ## List of 3 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num [1:2] 1 2 ## ..$ : num [1:2] 3 4 ## $ :List of 3 ## ..$ : num 3 ## ..$ : num [1:2] 1 2 ## ..$ : chr &quot;lists are amazing!&quot; or you can use RStudio’s Environment pane: You can also create named lists: list4 &lt;- list(&quot;a&quot; = 2, &quot;b&quot; = 8, &quot;c&quot; = &quot;this is a named list&quot;) and you can access the elements in two ways: list4[[1]] ## [1] 2 or, for named lists: list4$c ## [1] &quot;this is a named list&quot; Lists are used extensively because they are so flexible. You can build lists of datasets and apply functions to all the datasets at once, build lists of models, lists of plots, etc… In the later chapters we are going to learn all about them. Lists are central objects in a functional programming workflow for interactive statistical analysis. 2.8 The data.frame and tibble classes In the next chapter we are going to learn how to import datasets into R. Once you import data, the resulting object is either a data.frame or a tibble depending on which package you used to import the data. tibbles extend data.frames so if you know about data.frame objects already, working with tibbles will be very easy. tibbles have a better print() method, and some other niceties. However, I want to stress that these objects are central to R and are thus very important; they are actually special cases of lists, discussed above. There are different ways to print a data.frame or a tibble if you wish to inspect it. You can use View(my_data) to show the my_data data.frame in the View pane of RStudio: You can also use the str() function: str(my_data) And if you need to access an individual column, you can use the $ sign, same as for a list: my_data$col1 2.9 Formulas We will learn more about formulas later, but because it is an important object, it is useful if you already know about them early on. A formula is defined in the following way: my_formula &lt;- ~x class(my_formula) ## [1] &quot;formula&quot; Formula objects are defined using the ~ symbol. Formulas are useful to define statistical models, for example for a linear regression: lm(y ~ x) or also to define anonymous functions, but more on this later. 2.10 Models A statistical model is an object like any other in R: data(mtcars) my_model &lt;- lm(mpg ~ hp, mtcars) class(my_model) ## [1] &quot;lm&quot; my_model is an object of class lm. You can apply different functions to a model object: summary(my_model) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.7121 -2.1122 -0.8854 1.5819 8.2360 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 30.09886 1.63392 18.421 &lt; 2e-16 *** ## hp -0.06823 0.01012 -6.742 1.79e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.863 on 30 degrees of freedom ## Multiple R-squared: 0.6024, Adjusted R-squared: 0.5892 ## F-statistic: 45.46 on 1 and 30 DF, p-value: 1.788e-07 This class will be explored in later chapters. 2.11 NULL, NA and NaN The NULL, NA and NaN classes are pretty special. NULL is returned when the result of function is undetermined. For example, consider list4: list4 ## $a ## [1] 2 ## ## $b ## [1] 8 ## ## $c ## [1] &quot;this is a named list&quot; if you try to access an element that does not exist, such as d, you will get NULL back: list4$d ## NULL NaNNmeans “Not a Number” and is returned when a function return something that is not a number: sqrt(-1) ## Warning in sqrt(-1): NaNs produced ## [1] NaN or: 0/0 ## [1] NaN Basically, numbers that cannot be represented as floating point numbers are NaN. Finally, there’s NA which is closely related to NaN but is used for missing values. NA stands for Not Available. There are several types of NAs: NA_integer_ NA_real_ NA_complex_ NA_character_ but these are in principle only used when you need to program your own functions and need to explicitely test for the missingness of, say, a character value. 2.12 Exercises Exercise 1 Try to create the following vector: \\[a = (6,3,8,9)\\] and add it this other vector: \\[b = (9,1,3,5)\\] and save the result to a new variable called result. Exercise 2 Using a and b from before, try to get their dot product. Try with a * b in the R console. What happened? Try to find the right function to get the dot product. Don’t hesitate to google the answer! Exercise 3 How can you create a matrix of dimension (30,30) filled with 2’s by only using the function matrix()? Exercise 4 Save your first name in a variable a and your surname in a variable b. What does the function: paste(a, b) do? Look at the help for paste() with ?paste or using the Help pane in RStudio. What does the optional argument sep do? Exercise 5 Define the following variables: a &lt;- 8, b &lt;- 3, c &lt;- 19. What do the following lines check? What do they return? a &gt; b a == b a != b a &lt; b (a &gt; b) &amp;&amp; (a &lt; c) (a &gt; b) &amp;&amp; (a &gt; c) (a &gt; b) || (a &lt; b) Exercise 6 Define the following matrix: \\[ \\text{matrix_a} = \\left( \\begin{array}{ccc} 9 &amp; 4 &amp; 12 \\\\ 5 &amp; 0 &amp; 7 \\\\ 2 &amp; 6 &amp; 8 \\\\ 9 &amp; 2 &amp; 9 \\end{array} \\right) \\] What does matrix_a &gt;= 5 do? What does matrix_a[ , 2] do? Can you find which function gives you the transpose of this matrix? Exercise 7 Solve the following system of equations using the solve() function: \\[ \\left( \\begin{array}{cccc} 9 &amp; 4 &amp; 12 &amp; 2 \\\\ 5 &amp; 0 &amp; 7 &amp; 9\\\\ 2 &amp; 6 &amp; 8 &amp; 0\\\\ 9 &amp; 2 &amp; 9 &amp; 11 \\end{array} \\right) \\times \\left( \\begin{array}{ccc} x \\\\ y \\\\ z \\\\ t \\\\ \\end{array}\\right) = \\left( \\begin{array}{ccc} 7\\\\ 18\\\\ 1\\\\ 0 \\end{array} \\right) \\] Exercise 8 Load the mtcars data (mtcars is include in R, so you only need to use the data() function to load the data): data(mtcars) if you run class(mtcars), you get “data.frame”. Try now with typeof(mtcars). The answer is now “list”! This is because the class of an object is an attribute of that object, which can even be assigned by the user: class(mtcars) &lt;- &quot;don&#39;t do this&quot; class(mtcars) ## [1] &quot;don&#39;t do this&quot; The type of an object is R’s internal type of that object, which cannot be manipulated by the user. It is always useful to know the type of an object (not just its class). For example, in the particular case of data frames, because the type of a data frame is a list, you can use all that you learned about lists to manipulate data frames! Recall that $ allowed you to select the element of a list for instance: my_list &lt;- list(&quot;one&quot; = 1, &quot;two&quot; = 2, &quot;three&quot; = 3) my_list$one ## [1] 1 Because data frames are nothing but fancy lists, this is why you can access columns the same way: mtcars$mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 ## [15] 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 ## [29] 15.8 19.7 15.0 21.4 "]
]
