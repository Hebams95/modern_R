[
["data-types-and-objects.html", "Chapter 3 Data types and objects 3.1 The numeric class 3.2 The character class 3.3 The factor class 3.4 The Date class 3.5 Vectors and matrices 3.6 The logical class 3.7 The list class 3.8 The data.frame and tibble classes 3.9 Formulas 3.10 Models 3.11 The is.*() and as.*() functions 3.12 Exercises", " Chapter 3 Data types and objects All objects in R have a given type. You already know most of them, as these types are also used in mathematics. Integers, floating point numbers, or floats, matrices, etc, are all objects you are already familiar with. But R has other, maybe lesser known data types (that you can find in a lot of other programming languages) that you need to become familiar with. But first, we need to learn how to assign a value to a variable. This can be done in two ways: a &lt;- 3 or a &lt;- 3 there is almost no difference between these two approaches. You would need to pay attention to this, and use &lt;- in very specific situations to which you will very likely never be confronted to. Another thing you must know before going further is that you can convert from one type to another using functions that start with as.(), such as as.character(), as.numeric(), as.logical(), etc… For example, as.character(1) converts the number 1 to the character (or string) “1”. There are also is.character(), is.numeric() and so on that test if the object is of the required class. These functions exist for each object type, and are very useful. Make sure you remember them! 3.1 The numeric class To define single numbers, you can do the following: a &lt;- 3 The class() function allows you to check the class of an object: class(a) ## [1] &quot;numeric&quot; Decimals are defined with the character .: a &lt;- 3.14 3.2 The character class Use &quot; &quot; to define characters (called strings in other programming languages): a &lt;- &quot;this is a string&quot; class(a) ## [1] &quot;character&quot; A very nice package to work with characters is {stringr}, which is also part of the {tidyverse}. 3.3 The factor class Factors look like characters, but are very different. They are the representation of categorical variables. A {tidyverse} package to work with factors is {forcats}. You would rarely use factor variables outside of datasets, so for now, it is enough to know that this class exists. We are going to manipulate factor variables in the next chatper 5. 3.4 The Date class Dates also look like characters, but are very different too: as.Date(&quot;2019/03/19&quot;) ## [1] &quot;2019-03-19&quot; class(as.Date(&quot;2019/03/19&quot;)) ## [1] &quot;Date&quot; Manipulating dates and time can be tricky, but thankfully there’s a {tidyverse} package for that, called {lubridate}. We are going to go over this package in Chapter 5. 3.5 Vectors and matrices You can create a vector in different ways. But first of all, it is important to understand that a vector in most programming languages is nothing more than a list of things. These things can be numbers (either integers or floats), strings, or even other vectors. 3.5.1 The c() function A very important function that allows you to build a vector is c(): a &lt;- c(1,2,3,4,5) This creates a vector with elements 1, 2, 3, 4, 5. If you check its class: class(a) ## [1] &quot;numeric&quot; This can be confusing: you where probably expecting a to be of class vector or something similar. This is not the case if you use c() to create the vector, because c() doesn’t build a vector in the mathematical sense, but rather a list with numbers. Checking its dimension: dim(a) ## NULL returns NULL because a list doesn’t have a dimension, that’s why the dim() function returns NULL. If you want to create a true vector, you need to use cbind() or rbind(). 3.5.2 cbind() and rbind() You can create a true vector with cbind(): a &lt;- cbind(1,2,3,4,5) Check its class now: class(a) ## [1] &quot;matrix&quot; This is exactly what we expected. Let’s check its dimension: dim(a) ## [1] 1 5 This returns the dimension of a using the LICO notation (number of LInes first, the number of COlumns). It is also possible to bind vectors together to create a matrix. b &lt;- cbind(6,7,8,9,10) Now let’s put vector a and b into a matrix called matrix_c using rbind(). rbind() functions the same way as cbind() but glues the vectors together by rows and not by columns. matrix_c &lt;- rbind(a,b) print(matrix_c) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 3.5.3 The matrix class R also has support for matrices. For example, you can create a matrix of dimension (5,5) filled with 0’s with the matrix() function: matrix_a &lt;- matrix(0, nrow &lt;- 5, ncol &lt;- 5) If you want to create the following matrix: \\[ B &lt;- \\left( \\begin{array}{ccc} 2 &amp; 4 &amp; 3 \\\\ 1 &amp; 5 &amp; 7 \\end{array} \\right) \\] you would do it like this: B &lt;- matrix(c(2, 4, 3, 1, 5, 7), nrow &lt;- 2, byrow &lt;- TRUE) The option byrow &lt;- TRUE means that the rows of the matrix will be filled first. You can access individual elements of matrix_a like so: matrix_a[2, 3] ## [1] 0 and R returns its value, 0. We can assign a new value to this element if we want. Try: matrix_a[2, 3] &lt;- 7 and now take a look at matrix_a again. print(matrix_a) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 0 0 7 0 0 ## [3,] 0 0 0 0 0 ## [4,] 0 0 0 0 0 ## [5,] 0 0 0 0 0 Recall our vector b: b &lt;- cbind(6,7,8,9,10) To access its third element, you can simply write: b[3] ## [1] 8 3.6 The logical class This class is the result of logical comparisons, for example, if you type: 4 &gt; 3 ## [1] TRUE R returns true. If we save this in a variable k: k &lt;- 4 &gt; 3 and check k’s class: class(k) ## [1] &quot;logical&quot; R returns logical. In other programming languages, logicals are often called bools. A logical variable can only have two values, either TRUE or FALSE. 3.7 The list class The list class is a very flexible class, and thus, very useful. You can put anything inside a list, such as numbers: list1 &lt;- list(3, 2) or other lists constructed with c(): list2 &lt;- list(c(1, 2), c(3, 4)) you can also put objects of different classes in the same list: list3 &lt;- list(3, c(1, 2), &quot;lists are amazing!&quot;) and of course create list of lists: my_lists &lt;- list(list1, list2, list3) To check the contents of a list, you can use the structure function str(): str(my_lists) ## List of 3 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num [1:2] 1 2 ## ..$ : num [1:2] 3 4 ## $ :List of 3 ## ..$ : num 3 ## ..$ : num [1:2] 1 2 ## ..$ : chr &quot;lists are amazing!&quot; or you can use RStudio’s Environment pane: You can also create named lists: list4 &lt;- list(&quot;a&quot; &lt;- 2, &quot;b&quot; &lt;- 8, &quot;c&quot; &lt;- &quot;this is a named list&quot;) and you can access the elements in two ways: list4[[1]] ## [1] 2 or, for named lists: list4$c ## NULL Lists are used extensively because they are so flexible. You can build lists of datasets and apply functions to all the datasets at once, build lists of models, lists of plots, etc… In the later chapters we are going to learn all about them. Actually, I use lists very often, but never vectors or matrices. Lists are much more flexible and in R, datasets behave like lists. 3.8 The data.frame and tibble classes In the next chapter we are going to learn how to import datasets into R. Once you import data, the resulting object is either a data.frame or a tibble depending on which package you used to import the data. tibbles extend data.frames so if you know about data.frame objects already, working with tibbles will be very easy. tibbles have a better print() method, and some other niceties. If you want to know more, I go into more detail in my other book but for our purposes, there’s not much you need to know about data.frame and tibble objects, apart that this is the representation of a dataset when loaded into R. However, I want to stress that these objects are central to R and are thus very important. There are different ways to print a data.frame or a tibble if you wish to inspect it. You can use View(my_data) to show the my_data data.frame in the View pane of RStudio: You can also use the str() function: str(my_data) And if you need to access an individual column, you can use the $ sign, same as for a list: my_data$col1 3.9 Formulas We will learn more about formulas later, but because it is an important object, it is useful if you already know about them early on. A formula is defined in the following way: my_formula &lt;- ~x class(my_formula) ## [1] &quot;formula&quot; Formula objects are defined using the ~ symbol. Formulas are useful to define statistical models, for example for a linear regression: lm(y ~ x) or also to define anonymous functions, but more on this later. 3.10 Models A statistical model is an object like any other in R: data(mtcars) my_model &lt;- lm(mpg ~ hp, mtcars) class(my_model) ## [1] &quot;lm&quot; my_model is an object of class lm. You can apply different functions to a model object: summary(my_model) ## ## Call: ## lm(formula = mpg ~ hp, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5.7121 -2.1122 -0.8854 1.5819 8.2360 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 30.09886 1.63392 18.421 &lt; 2e-16 *** ## hp -0.06823 0.01012 -6.742 1.79e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.863 on 30 degrees of freedom ## Multiple R-squared: 0.6024, Adjusted R-squared: 0.5892 ## F-statistic: 45.46 on 1 and 30 DF, p-value: 1.788e-07 This class will be explored in later chapters. 3.11 The is.*() and as.*() functions is.*() and as.*() are very powerful, and this is the right moment to introduce them. is.*() test the class of an object: is.integer(5) ## [1] FALSE is.character(198) ## [1] FALSE as.*() functions convert from one type to another: as.character(7) ## [1] &quot;7&quot; as.numeric(&quot;23.12&quot;) ## [1] 23.12 but only if it makes sense: as.numeric(&quot;This will return NA&quot;) ## Warning: NAs introduced by coercion ## [1] NA Keep these in mind, because they are going to be very useful. The {purrr} package introduces similar functions, is_*() and as_*(). We will explore them in Chapter 9. 3.12 Exercises Exercise 1 Try to create the following vector: \\[a = (6,3,8,9)\\] and add it this other vector: \\[b = (9,1,3,5)\\] and save the result to a new variable called result. Exercise 2 Using a and b from before, try to get their dot product. Try with a * b in the R console. What happened? Try to find the right function to get the dot product. Don’t hesitate to google the answer! Exercise 3 How can you create a matrix of dimension (30,30) filled with 2’s by only using the function matrix()? Exercise 4 Save your first name in a variable a and your surname in a variable b. What does the function: paste(a, b) do? Look at the help for paste() with ?paste or using the Help pane in RStudio. What does the optional argument sep do? Exercise 5 Define the following variables: a &lt;- 8, b &lt;- 3, c &lt;- 19. What do the following lines check? What do they return? a &gt; b a == b a != b a &lt; b (a &gt; b) &amp;&amp; (a &lt; c) (a &gt; b) &amp;&amp; (a &gt; c) (a &gt; b) || (a &lt; b) Exercise 6 Define the following matrix: \\[ \\text{matrix_a} = \\left( \\begin{array}{ccc} 9 &amp; 4 &amp; 12 \\\\ 5 &amp; 0 &amp; 7 \\\\ 2 &amp; 6 &amp; 8 \\\\ 9 &amp; 2 &amp; 9 \\end{array} \\right) \\] What does matrix_a &gt;= 5 do? What does matrix_a[ , 2] do? Can you find which function gives you the transpose of this matrix? Exercise 7 Solve the following system of equations using the solve() function: \\[ \\left( \\begin{array}{cccc} 9 &amp; 4 &amp; 12 &amp; 2 \\\\ 5 &amp; 0 &amp; 7 &amp; 9\\\\ 2 &amp; 6 &amp; 8 &amp; 0\\\\ 9 &amp; 2 &amp; 9 &amp; 11 \\end{array} \\right) \\times \\left( \\begin{array}{ccc} x \\\\ y \\\\ z \\\\ t \\\\ \\end{array}\\right) = \\left( \\begin{array}{ccc} 7\\\\ 18\\\\ 1\\\\ 0 \\end{array} \\right) \\] Exercise 8 Load the mtcars data (mtcars is include in R, so you only need to use the data() function to load the data): data(mtcars) if you run class(mtcars), you get “data.frame”. Try now with typeof(mtcars). The answer is now “list”! This is because the class of an object is an attribute of that object, which can even be assigned by the user: class(mtcars) &lt;- &quot;don&#39;t do this&quot; class(mtcars) ## [1] &quot;don&#39;t do this&quot; The type of an object is R’s internal type of that object, which cannot be manipulated by the user. It is always useful to know the type of an object (not just its class). For example, in the particular case of data frames, because the type of a data frame is a list, you can use all that you learned about lists to manipulate data frames! Recall that $ allowed you to select the element of a list for instance: my_list &lt;- list(&quot;one&quot; = 1, &quot;two&quot; = 2, &quot;three&quot; = 3) my_list$one ## [1] 1 Because data frames are nothing but fancy lists, this is why you can access columns the same way: mtcars$mpg ## [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 ## [15] 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 ## [29] 15.8 19.7 15.0 21.4 "],
["functional-programming.html", "Chapter 9 Functional programming 9.1 Functions definition 9.2 Properties of functions 9.3 Functional programming with {purrr} 9.4 Using your functions inside mutate() 9.5 Working with a list of datasets 9.6 Mapping your homebrewed functions to lists of datasets 9.7 Functional programming and plotting 9.8 Functional programming and modeling 9.9 Exercises", " Chapter 9 Functional programming By now, you are pretty familiar with functions in R. Now, let’s introduce the functional programming paradigm, but first, let’s go over some formal definitions. 9.1 Functions definition You should be familiar with function definitions in R. For example, suppose you want to compute the square root of a number and want to do so using Newton’s algorithm: sqrt_newton &lt;- function(a, init, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) } return(init) } You can then use this function to get the square root of a number: sqrt_newton(16, 2) ## [1] 4.00122 We are using a while loop inside the body. The body of a function are the instructions that define the function. You can get the body of a function with body(some_func) of the function. In pure functional programming languages, like Haskell, you don’t have loops. How can you program without loops, you may ask? In functional programming, loops are replaced by recursion, which we already discussed in the previous chapter. Let’s rewrite our little example above with recursion: sqrt_newton_recur &lt;- function(a, init, eps = 0.01){ if(abs(init**2 - a) &lt; eps){ result &lt;- init } else { init &lt;- 1/2 * (init + a/init) result &lt;- sqrt_newton_recur(a, init, eps) } return(result) } sqrt_newton_recur(16, 2) ## [1] 4.00122 R is not a pure functional programming language though, so we can still use loops (be it while or for loops) in the bodies of our functions. As discussed in the previous chapter, it is actually better, performance-wise, to use loops instead of recursion, because R is not tail-call optimized. I won’t got into the details of what tail-call optimization is but just remember that if performance is important a loop will be faster. However, sometimes, it is easier to write a function using recursion. I personally tend to avoid loops if performance is not important, because I find that code that avoids loops is easier to read and debug. However, knowing that you can use loops is reassuring. In the coming sections I will show you some built-in functions that make it possible to avoid writing loops and that don’t rely on recursion, so performance won’t be penalized. 9.2 Properties of functions Mathematical functions have a nice property: we always get the same output for a given input. This is called referential transparency and we should aim to write our R functions in such a way. For example, the following function: increment &lt;- function(x){ return(x + 1) } Is a referential transparent function. We always get the same result for any x that we give to this function. This: increment(10) ## [1] 11 will always produce 11. However, this one: increment_opaque &lt;- function(x){ return(x + spam) } is not a referential transparent function, because its value depends on the global variable spam. spam &lt;- 1 increment_opaque(10) ## [1] 11 will only produce 11 if spam = 1. But what if spam = 19? spam &lt;- 19 increment_opaque(10) ## [1] 29 To make increment_opaque() a referential transparent function, it is enough to make spam an argument: increment_not_opaque &lt;- function(x, spam){ return(x + spam) } Now even if there is a global variable called spam, this will not influence our function: spam &lt;- 19 increment_not_opaque(10, 34) ## [1] 44 This is because the variable spam defined in the body of the function is a local variable. It could have been called anything else, really. Avoiding opaque functions makes our life easier. Another property that adepts of functional programming value is that functions should have no, or very limited, side-effects. This means that functions should not change the state of your program. For example this function (which is not a referential transparent function): count_iter &lt;- 0 sqrt_newton_side_effect &lt;- function(a, init, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) count_iter &lt;&lt;- count_iter + 1 # The &quot;&lt;&lt;-&quot; symbol means that we assign the } # RHS value in a variable in the global environment return(init) } If you look in the environment pane, you will see that count_iter equals 0. Now call this function with the following arguments: sqrt_newton_side_effect(16000, 2) ## [1] 126.4911 print(count_iter) ## [1] 9 If you check the value of count_iter now, you will see that it increased! This is a side effect, because the function changed something outside of its scope. It changed a value in the global environment. In general, it is good practice to avoid side-effects. For example, we could make the above function not have any side effects like this: sqrt_newton_count &lt;- function(a, init, count_iter = 0, eps = 0.01){ while(abs(init**2 - a) &gt; eps){ init &lt;- 1/2 *(init + a/init) count_iter &lt;- count_iter + 1 } return(c(init, count_iter)) } Now, this function returns a list with two elements, the result, and the number of iterations it took to get the result: sqrt_newton_count(16000, 2) ## [1] 126.4911 9.0000 Writing to disk is also considered a side effect, because the function changes something (a file) outside its scope. But this cannot be avoided since you want to write to disk. Just remember: try to avoid having functions changing variables in the global environment unless you have a very good reason of doing so. Finally, another property of mathematical functions, is that they do one single thing. Functional programming purists also program their functions to do one single task. This has benefits, but can complicate things. The function we wrote previously does two things: it computes the square root of a number and also returns the number of iterations it took to compute the result. However, this is not a bad thing; the function is doing two tasks, but these tasks are related to each other and it makes sense to have them together. My piece of advice: avoid having functions that do many unrelated things. This makes debugging harder. In conclusion: you should strive for referential transparency, try to avoid side effects unless you have a good reason to have them and try to keep your functions short and do as little tasks as possible. This makes testing and debugging easier, as you will see. 9.3 Functional programming with {purrr} Hadley Wickham developed a package called purrr which contains a lot of very useful functions. 9.3.1 The map*() family of functions In the previous section we saw how to map a function to each element of a list. Each version of an *apply() function has a different purpose, but it is not very easy to remember which one returns a list, which other one returns an atomic vector and so on. If you’re working on data frames you can use apply() to sum (for example) over columns or rows, because you can specify which MARGIN you want to sum over. But you do not get a data frame back. In the purrr package, each of the functions that do mapping have a similar name. The first part of these functions’ names all start with map_ and the second part tells you what this function is going to output. For example, if you want doubles out, you would use map_dbl(). If you are working on data frames want a data frame back, you would use map_df(). These are much more intuitive and easier to remember and we’re going to learn how to use them in the chapter about The Tidyverse. For now, let’s just focus on the basic functions, map() and reduce() (and some variants of reduce()). To map a function to every element of a list, simply use map(): library(&quot;purrr&quot;) numbers &lt;- c(7, 8, 19, 64) map(numbers, sqrt_newton, init = 1) ## [[1]] ## [1] 2.645767 ## ## [[2]] ## [1] 2.828469 ## ## [[3]] ## [1] 4.358902 ## ## [[4]] ## [1] 8.000002 If you want print “hello” using a function from purrr you would need to use rerun(): rerun(10, &quot;hello&quot;) ## [[1]] ## [1] &quot;hello&quot; ## ## [[2]] ## [1] &quot;hello&quot; ## ## [[3]] ## [1] &quot;hello&quot; ## ## [[4]] ## [1] &quot;hello&quot; ## ## [[5]] ## [1] &quot;hello&quot; ## ## [[6]] ## [1] &quot;hello&quot; ## ## [[7]] ## [1] &quot;hello&quot; ## ## [[8]] ## [1] &quot;hello&quot; ## ## [[9]] ## [1] &quot;hello&quot; ## ## [[10]] ## [1] &quot;hello&quot; rerun() simply runs an expression (which can be arbitrarily complex) n times, whereas map() maps a function to a list of inputs, so to achieve the same with map(), you need to map the print() function to a vector of characters: map(rep(&quot;hello&quot;, 10), print) ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [1] &quot;hello&quot; ## [[1]] ## [1] &quot;hello&quot; ## ## [[2]] ## [1] &quot;hello&quot; ## ## [[3]] ## [1] &quot;hello&quot; ## ## [[4]] ## [1] &quot;hello&quot; ## ## [[5]] ## [1] &quot;hello&quot; ## ## [[6]] ## [1] &quot;hello&quot; ## ## [[7]] ## [1] &quot;hello&quot; ## ## [[8]] ## [1] &quot;hello&quot; ## ## [[9]] ## [1] &quot;hello&quot; ## ## [[10]] ## [1] &quot;hello&quot; rep() is a function that creates a vector by repeating something, in this case the string “hello”, as many times as needed, here 10. The output here is a bit different that before though, because first you will see “hello” printed 10 times, but map() always returns a list, this means that you will also get a list where each element is the string “hello”. We know the standard map() function, which returns a list, but there are a number of variants of this function. map_dbl() returns an atomic vector of doubles: map_dbl(numbers, sqrt_newton, init = 1) ## [1] 2.645767 2.828469 4.358902 8.000002 map_chr() returns an atomic vector of strings: map_chr(numbers, sqrt_newton, init = 1) ## [1] &quot;2.645767&quot; &quot;2.828469&quot; &quot;4.358902&quot; &quot;8.000002&quot; map_lgl() returns an atomic vector of TRUE or FALSE: divisible &lt;- function(x, y){ if_else(x %% y == 0, TRUE, FALSE) } map_lgl(seq(1:100), divisible, 3) ## [1] FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE ## [12] TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE ## [23] FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE ## [34] FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE ## [45] TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE ## [56] FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE ## [67] FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE ## [78] TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE ## [89] FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE ## [100] FALSE There are also other interesting variants, such as map_if(): a &lt;- seq(1,10) map_if(a, (function(x) divisible(x, 2)), sqrt) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 1.414214 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 2 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 2.44949 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 2.828427 ## ## [[9]] ## [1] 9 ## ## [[10]] ## [1] 3.162278 I used map_if() to take the square root of only those numbers in vector a that are divisble by 2, by using an anonymous function that checks if a number is divisible by 2 (by wrapping divisible()). map_at() is similar to map_if() but maps the function at a position specified by the user: map_at(numbers, c(1, 3), sqrt) ## [[1]] ## [1] 2.645751 ## ## [[2]] ## [1] 8 ## ## [[3]] ## [1] 4.358899 ## ## [[4]] ## [1] 64 or if you have a named list: recipe &lt;- list(&quot;spam&quot; = 1, &quot;eggs&quot; = 3, &quot;bacon&quot; = 10) map_at(recipe, &quot;bacon&quot;, `*`, 2) ## $spam ## [1] 1 ## ## $eggs ## [1] 3 ## ## $bacon ## [1] 20 I used map_at() to double the quantity of bacon in the recipe (by using the * function, and specifying its second argument, 2. Try the following in the command prompt: `*`(3, 4)). map2() is the equivalent of mapply() and pmap() is the generalisation of map2() for more than 2 arguments: print(a) ## [1] 1 2 3 4 5 6 7 8 9 10 b &lt;- seq(1, 2, length.out = 10) print(b) ## [1] 1.000000 1.111111 1.222222 1.333333 1.444444 1.555556 1.666667 ## [8] 1.777778 1.888889 2.000000 map2(a, b, `*`) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2.222222 ## ## [[3]] ## [1] 3.666667 ## ## [[4]] ## [1] 5.333333 ## ## [[5]] ## [1] 7.222222 ## ## [[6]] ## [1] 9.333333 ## ## [[7]] ## [1] 11.66667 ## ## [[8]] ## [1] 14.22222 ## ## [[9]] ## [1] 17 ## ## [[10]] ## [1] 20 n &lt;- seq(1:10) pmap(list(a, b, n), rnorm) ## [[1]] ## [1] 1.106661 ## ## [[2]] ## [1] -0.5854979 1.8259355 ## ## [[3]] ## [1] -1.656370 -1.829796 1.223846 ## ## [[4]] ## [1] 2.954858 4.755305 -5.018860 2.653794 ## ## [[5]] ## [1] 0.5168793 4.5590805 5.5412789 -4.2540245 5.3337944 ## ## [[6]] ## [1] 4.2089795 5.8900265 5.5374253 5.2874796 -0.7207456 2.0702665 ## ## [[7]] ## [1] 7.6549886 6.8488324 -0.3328097 3.9247135 -6.6952170 5.4737770 ## [7] -8.0894826 ## ## [[8]] ## [1] 7.8318623 10.2721831 -5.2392860 1.4799999 0.4830797 13.5013845 ## [7] -6.4879258 9.1718745 ## ## [[9]] ## [1] 0.4540683 -5.4781622 2.5409110 -21.0913633 -8.7272550 -1.4912102 ## [7] 8.6172667 9.1013259 -4.6032108 ## ## [[10]] ## [1] 5.83269000 -0.51383948 19.49878608 -14.87620311 -11.70385673 ## [6] 1.74963533 0.03904016 -2.61463163 13.40050750 1.64485384 9.3.2 Reducing with purrr In the purrr package, you can find two more functions for folding: reduce() and reduce_right(). The difference between reduce() and reduce_right() is pretty obvious: reduce_right() starts from the right! a &lt;- seq(1, 10) reduce(a, `-`) ## [1] -53 reduce_right(a, `-`) ## [1] -35 For operations that are not commutative, this makes a difference. Other interesting folding functions are accumulate() and accumulate_right(): a &lt;- seq(1, 10) accumulate(a, `-`) ## [1] 1 -1 -4 -8 -13 -19 -26 -34 -43 -53 accumulate_right(a, `-`) ## [1] -35 -34 -32 -29 -25 -20 -14 -7 1 10 These two functions keep the intermediary results. In the previous chapter, we wrote a loop to compute the sum of the 100 first integers. We can do the same with purrr::reduce(): result = reduce(seq(1,100), `+`) print(result) ## [1] 5050 You certainly agree with me that is simpler to understand. You can even see what happens in more detail using accumulate: accumulate(seq(1, 100), `+`) ## [1] 1 3 6 10 15 21 28 36 45 55 66 78 91 105 ## [15] 120 136 153 171 190 210 231 253 276 300 325 351 378 406 ## [29] 435 465 496 528 561 595 630 666 703 741 780 820 861 903 ## [43] 946 990 1035 1081 1128 1176 1225 1275 1326 1378 1431 1485 1540 1596 ## [57] 1653 1711 1770 1830 1891 1953 2016 2080 2145 2211 2278 2346 2415 2485 ## [71] 2556 2628 2701 2775 2850 2926 3003 3081 3160 3240 3321 3403 3486 3570 ## [85] 3655 3741 3828 3916 4005 4095 4186 4278 4371 4465 4560 4656 4753 4851 ## [99] 4950 5050 9.3.3 safely() and possibly() safely() and possibly() are very useful functions. Consider the following situation: a &lt;- list(&quot;a&quot;, 4, 5) sqrt(a) Error in sqrt(a) : non-numeric argument to mathematical function Using map() or Map() will result in a similar error. safely() is an higher-order function that takes one function as an argument and executes it… safely, meaning the execution of the function will not stop if there is an error. The error message gets captured alongside valid results. a &lt;- list(&quot;a&quot;, 4, 5) safe_sqrt &lt;- safely(sqrt) map(a, safe_sqrt) ## [[1]] ## [[1]]$result ## NULL ## ## [[1]]$error ## &lt;simpleError in sqrt(x = x): non-numeric argument to mathematical function&gt; ## ## ## [[2]] ## [[2]]$result ## [1] 2 ## ## [[2]]$error ## NULL ## ## ## [[3]] ## [[3]]$result ## [1] 2.236068 ## ## [[3]]$error ## NULL possibly() works similarly, but also allows you to specify a return value in case of an error: possible_sqrt &lt;- possibly(sqrt, otherwise = NA_real_) map(a, possible_sqrt) ## [[1]] ## [1] NA ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 2.236068 Of course, in this particular example, the same effect could be obtained way more easily: sqrt(as.numeric(a)) ## Warning: NAs introduced by coercion ## [1] NA 2.000000 2.236068 However, in some situations, this trick does not work as intended (or at all), so possibly() and safely() are the way to go. 9.3.4 is_*() and as_*() functions Remember in Chapter 3, when I introduced is.*() and as.*() functions? I told you then that we were going to learn about is_*() and as_*() in Chapter 9. This is it! 9.3.5 «Transposing lists» Another interesting function is transpose(). It is not an alternative to the function t() from base but, has a similar effect. transpose() works on lists. Let’s take a look at the example from before: safe_sqrt &lt;- safely(sqrt, otherwise = NA_real_) map(a, safe_sqrt) ## [[1]] ## [[1]]$result ## [1] NA ## ## [[1]]$error ## &lt;simpleError in sqrt(x = x): non-numeric argument to mathematical function&gt; ## ## ## [[2]] ## [[2]]$result ## [1] 2 ## ## [[2]]$error ## NULL ## ## ## [[3]] ## [[3]]$result ## [1] 2.236068 ## ## [[3]]$error ## NULL The output is a list with the first element being a list with a result and an error message. One might want to have all the results in a single list, and all the error messages in another list. This is possible with transpose(): purrr::transpose(map(a, safe_sqrt)) ## $result ## $result[[1]] ## [1] NA ## ## $result[[2]] ## [1] 2 ## ## $result[[3]] ## [1] 2.236068 ## ## ## $error ## $error[[1]] ## &lt;simpleError in sqrt(x = x): non-numeric argument to mathematical function&gt; ## ## $error[[2]] ## NULL ## ## $error[[3]] ## NULL I explicitely call purrr::transpose() because there is also a data.table::transpose(), which is not the same function. You have to be careful about that sort of thing, because it can cause errors in your programs and debuging this type of error is a nightmare. 9.4 Using your functions inside mutate() Once you wrote a function, you can easily use it inside a pipe workflow: double_number &lt;- function(x){ x+x } mtcars %&gt;% mutate(double_mpg = double_number(mpg)) ## mpg cyl disp hp drat wt qsec vs am gear carb double_mpg ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 42.0 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 42.0 ## 3 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 45.6 ## 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 42.8 ## 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 37.4 ## 6 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 36.2 ## 7 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 28.6 ## 8 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 48.8 ## 9 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 45.6 ## 10 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 38.4 ## 11 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 35.6 ## 12 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 32.8 ## 13 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 34.6 ## 14 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 30.4 ## 15 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 20.8 ## 16 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 20.8 ## 17 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 29.4 ## 18 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 64.8 ## 19 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 60.8 ## 20 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 67.8 ## 21 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 43.0 ## 22 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 31.0 ## 23 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 30.4 ## 24 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 26.6 ## 25 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 38.4 ## 26 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 54.6 ## 27 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 52.0 ## 28 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 60.8 ## 29 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 31.6 ## 30 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 39.4 ## 31 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 30.0 ## 32 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 42.8 Granted this example is stupid, but it shows you, again, that functions you define are nothing special. You can use them just as any other. You can also avoid to define a function altogether, especially if you need an operation only once, by using the . like this: mtcars %&gt;% mutate(double_mpg = .$mpg + .$mpg) ## mpg cyl disp hp drat wt qsec vs am gear carb double_mpg ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 42.0 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 42.0 ## 3 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 45.6 ## 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 42.8 ## 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 37.4 ## 6 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 36.2 ## 7 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 28.6 ## 8 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 48.8 ## 9 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 45.6 ## 10 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 38.4 ## 11 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 35.6 ## 12 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 32.8 ## 13 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 34.6 ## 14 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 30.4 ## 15 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 20.8 ## 16 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 20.8 ## 17 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 29.4 ## 18 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 64.8 ## 19 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 60.8 ## 20 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 67.8 ## 21 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 43.0 ## 22 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 31.0 ## 23 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 30.4 ## 24 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 26.6 ## 25 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 38.4 ## 26 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 54.6 ## 27 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 52.0 ## 28 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 60.8 ## 29 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 31.6 ## 30 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 39.4 ## 31 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 30.0 ## 32 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 42.8 9.5 Working with a list of datasets 9.5.1 Using map() to work on lists of datasets This is our first encouter with a typical functional programming function, map(). Let’s read the list of datasets from the previous chapter: paths &lt;- Sys.glob(&quot;datasets/unemployment/*.csv&quot;) all_datasets &lt;- import_list(paths) str(all_datasets) ## List of 4 ## $ unemp_2013:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of which: Wage-earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of which: Non-wage-earners: int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ Unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ Active population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## ..$ Year : int [1:118] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ unemp_2014:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of which: Wage-earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of which: Non-wage-earners: int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ Unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ Active population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## ..$ Year : int [1:118] 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ unemp_2015:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of which: Wage-earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of which: Non-wage-earners: int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ Active population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## ..$ Year : int [1:118] 2015 2015 2015 2015 2015 2015 2015 2015 2015 2015 ... ## $ unemp_2016:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of which: Wage-earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of which: Non-wage-earners: int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ Active population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.15 5.04 4.84 3.01 4.3 ... ## ..$ Year : int [1:118] 2016 2016 2016 2016 2016 2016 2016 2016 2016 2016 ... For working with lists, another package from the tidyverse that is very useful, is called purrr. purrr will be presented in-depth in Chapter 9. The first thing we are going to do is use a function to clean the names of the datasets. These names are not very easy to work with; there are spaces, and it would be better if the names of the columns would be all lowercase. For this we are going to use the function clean_names() from the janitor package. For a single dataset, I would write this: library(janitor) one_dataset = one_dataset %&gt;% clean_names() and I would get a dataset with column names in lowercase and spaces replaced by _ (and other corrections). How can I apply, or map, this function to each dataset in the list? To do this I need to use purrr::map(): library(purrr) all_datasets = all_datasets %&gt;% map(clean_names) all_datasets %&gt;% glimpse() ## List of 4 ## $ unemp_2013:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of_which_wage_earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of_which_non_wage_earners : int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ active_population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## ..$ year : int [1:118] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ unemp_2014:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of_which_wage_earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of_which_non_wage_earners : int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ active_population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## ..$ year : int [1:118] 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ unemp_2015:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of_which_wage_earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of_which_non_wage_earners : int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ active_population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## ..$ year : int [1:118] 2015 2015 2015 2015 2015 2015 2015 2015 2015 2015 ... ## $ unemp_2016:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of_which_wage_earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of_which_non_wage_earners : int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ active_population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.15 5.04 4.84 3.01 4.3 ... ## ..$ year : int [1:118] 2016 2016 2016 2016 2016 2016 2016 2016 2016 2016 ... So now, what if I want to know, for each dataset, which communes have an unemployment rate that is less than, say, 3%? For a single dataset I would do something like this: one_dataset %&gt;% filter(unemployment_rate_in_percent &lt; 3) But for a list of datasets, map() is needed (and as you will see, that is not all that is needed): all_datasets %&gt;% map(~filter(., unemployment_rate_in_percent &lt; 3)) ## $unemp_2013 ## commune total_employed_population of_which_wage_earners ## 1 Garnich 844 750 ## 2 Leudelange 1064 937 ## 3 Bech 526 463 ## of_which_non_wage_earners unemployed active_population ## 1 94 25 869 ## 2 127 32 1096 ## 3 63 16 542 ## unemployment_rate_in_percent year ## 1 2.876870 2013 ## 2 2.919708 2013 ## 3 2.952030 2013 ## ## $unemp_2014 ## commune total_employed_population of_which_wage_earners ## 1 Garnich 845 757 ## 2 Leudelange 1102 965 ## 3 Bech 543 476 ## 4 Flaxweiler 879 789 ## of_which_non_wage_earners unemployed active_population ## 1 88 19 864 ## 2 137 34 1136 ## 3 67 15 558 ## 4 90 27 906 ## unemployment_rate_in_percent year ## 1 2.199074 2014 ## 2 2.992958 2014 ## 3 2.688172 2014 ## 4 2.980132 2014 ## ## $unemp_2015 ## commune total_employed_population of_which_wage_earners ## 1 Bech 520 450 ## 2 Bous 750 680 ## of_which_non_wage_earners unemployed active_population ## 1 70 14 534 ## 2 70 22 772 ## unemployment_rate_in_percent year ## 1 2.621723 2015 ## 2 2.849741 2015 ## ## $unemp_2016 ## commune total_employed_population of_which_wage_earners ## 1 Reckange-sur-Mess 980 850 ## 2 Bech 520 450 ## 3 Betzdorf 1500 1350 ## 4 Flaxweiler 910 820 ## of_which_non_wage_earners unemployed active_population ## 1 130 30 1010 ## 2 70 11 531 ## 3 150 45 1545 ## 4 90 24 934 ## unemployment_rate_in_percent year ## 1 2.970297 2016 ## 2 2.071563 2016 ## 3 2.912621 2016 ## 4 2.569593 2016 I know what you’re thinking… what the hell?. Let me explain: map() needs a function to map to each element of the list. all_datasets is the list to which I want to map the function. But what function? filter() is the function I need, so why doesn’t: all_datasets %&gt;% map(filter(unemployment_rate_in_percent &lt; 3)) work? This is a bit complicated, and has to do with what is called environments. If you try to run the code above, you will get this error message: Error in filter(unemployment_rate_in_percent &lt; 3) : object &#39;unemployment_rate_in_percent&#39; not found I won’t go into details, but by writing ~filter(., unemployment_rate_in_percent &lt; 3), which is a formula (~ is the symbol to define formulas, more on this in the later chapters), map() converts it to a function that it can use. If you want to know more about this, you can read it in Advanced R by Hadley Wickham, but it is an advanced topic. 9.6 Mapping your homebrewed functions to lists of datasets Before merging these datasets together, we would need them to have a year column indicating the year. It would also be helpful if gave names to these datasets. For this task, we can use purrr::set_names(): all_datasets = set_names(all_datasets, as.character(seq(2013, 2016))) Let’s take a look at the list now: str(all_datasets) As you can see, each data.frame object contained in the list has been renamed. You can thus access them with the $ operator: 9.6.1 Data frames and reduce Using map() we now know how to apply a function to each dataset of a list. But maybe it would be easier to merge all the datasets first, and then manipulate them? Before that though, I am going to teach you how to use purrr::reduce(), another very powerful function that works on lists. This is a function that you can find in other programming languages, but sometimes it is called fold. I think that the following example illustrates the power of reduce() well: numbers = seq(1, 5) # Create a vector with the numbers 1 to 5 reduce(numbers, `+`, .init = 0) ## [1] 15 reduce() takes a function as an argument, here the function +1 and then does the following computation: 0 + numbers[1] + numbers[2] + numbers[3]... It applies the user supplied function successively but has to start with something, so we give it the argument init also. This argument is actually optional, but I show it here because in some cases it might be useful to start the computations at another value than 0.reduce() generalizes functions that only take two arguments. If you were to write a function that returns the minimum between two numbers: my_min = function(a, b){ if(a &lt; b){ return(a) } else { return(b) } } You could use reduce() to get the minimum of a list of numbers: numbers2 = c(3, 1, -8, 9) reduce(numbers2, my_min) ## [1] -8 As long as you provide a function and a list of elements to reduce(), you will get a single output. So how could reduce() help us with merging all the datasets that are in the list? dplyr comes with a lot of function to merge two datasets. Remember that I said before that reduce() allows you to generalize a function of two arguments? Let’s try it with our list of datasets: unemp_lux = reduce(all_datasets, full_join) ## Joining, by = c(&quot;commune&quot;, &quot;total_employed_population&quot;, &quot;of_which_wage_earners&quot;, &quot;of_which_non_wage_earners&quot;, &quot;unemployed&quot;, &quot;active_population&quot;, &quot;unemployment_rate_in_percent&quot;, &quot;year&quot;) ## Joining, by = c(&quot;commune&quot;, &quot;total_employed_population&quot;, &quot;of_which_wage_earners&quot;, &quot;of_which_non_wage_earners&quot;, &quot;unemployed&quot;, &quot;active_population&quot;, &quot;unemployment_rate_in_percent&quot;, &quot;year&quot;) ## Joining, by = c(&quot;commune&quot;, &quot;total_employed_population&quot;, &quot;of_which_wage_earners&quot;, &quot;of_which_non_wage_earners&quot;, &quot;unemployed&quot;, &quot;active_population&quot;, &quot;unemployment_rate_in_percent&quot;, &quot;year&quot;) glimpse(unemp_lux) ## Observations: 472 ## Variables: 8 ## $ commune &lt;chr&gt; &quot;Grand-Duche de Luxembourg&quot;, &quot;Can... ## $ total_employed_population &lt;int&gt; 223407, 17802, 1703, 844, 1431, 4... ## $ of_which_wage_earners &lt;int&gt; 203535, 15993, 1535, 750, 1315, 3... ## $ of_which_non_wage_earners &lt;int&gt; 19872, 1809, 168, 94, 116, 294, 2... ## $ unemployed &lt;int&gt; 19287, 1071, 114, 25, 74, 261, 98... ## $ active_population &lt;int&gt; 242694, 18873, 1817, 869, 1505, 4... ## $ unemployment_rate_in_percent &lt;dbl&gt; 7.947044, 5.674773, 6.274078, 2.8... ## $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 201... full_join() is one of the dplyr function that merges data. There are others that might be useful depending on the kind of join operation you need. Let’s write this data to disk as we’re going to keep using it for the next chapters: export(unemp_lux, &quot;datasets/unemp_lux.csv&quot;) 9.7 Functional programming and plotting In this section, we are going to learn how to use the possibilities offered by the purrr package and how it can work together with ggplot2 to generate many plots. This is a more advanced topic, but what comes next is also what makes R, and the functional programming paradigm so powerful. For example, suppose that instead of wanting a single plot with the unemployment rate of each commune, you need one unemployment plot, per commune: unemp_lux_data %&gt;% filter(division == &quot;Luxembourg&quot;) %&gt;% ggplot(aes(year, unemployment_rate_in_percent, group = division)) + theme_minimal() + labs(title = &quot;Unemployment in Luxembourg&quot;, x = &quot;Year&quot;, y = &quot;Rate&quot;) + geom_line() and then you would write the same for “Esch-sur-Alzette” and also for “Wiltz”. If you only have to make to make these 3 plots, copy and pasting the above lines is no big deal: unemp_lux_data %&gt;% filter(division == &quot;Esch-sur-Alzette&quot;) %&gt;% ggplot(aes(year, unemployment_rate_in_percent, group = division)) + theme_minimal() + labs(title = &quot;Unemployment in Esch-sur-Alzette&quot;, x = &quot;Year&quot;, y = &quot;Rate&quot;) + geom_line() unemp_lux_data %&gt;% filter(division == &quot;Wiltz&quot;) %&gt;% ggplot(aes(year, unemployment_rate_in_percent, group = division)) + theme_minimal() + labs(title = &quot;Unemployment in Esch-sur-Alzette&quot;, x = &quot;Year&quot;, y = &quot;Rate&quot;) + geom_line() Put copy and pasting is error prone. Can you spot the copy-paste mistake I made? And what if you have to create the above plots for all 108 Luxembourguish communes? That’s a lot of copy pasting. What if, once you are done copy pasting, you have to change something, for example, the theme? You could use the search and replace function of RStudio, true, but sometimes search and replace can also introduce bugs and typos. You can avoid all these issues by using purrr::map(). What do you need to map over? The commune names. So let’s create a vector of commune names: communes = list(&quot;Luxembourg&quot;, &quot;Esch-sur-Alzette&quot;, &quot;Wiltz&quot;) Now we can create the graphs using map(), or map2() to be exact: plots_tibble = unemp_lux_data %&gt;% filter(division %in% communes) %&gt;% group_by(division) %&gt;% nest() %&gt;% mutate(plot = map2(.x = data, .y = division, ~ggplot(data = .x) + theme_minimal() + geom_line(aes(year, unemployment_rate_in_percent, group = 1)) + labs(title = paste(&quot;Unemployment in&quot;, .y)))) Let’s study this line by line: the first line is easy, we simply use filter() to keep only the communes we are interested in. Then we group by division and use tidyr::nest(). As a refresher, let’s take a look at what this does: unemp_lux_data %&gt;% filter(division %in% communes) %&gt;% group_by(division) %&gt;% nest() ## # A tibble: 3 x 2 ## division data ## &lt;chr&gt; &lt;list&gt; ## 1 Esch-sur-Alzette &lt;tibble [15 × 7]&gt; ## 2 Luxembourg &lt;tibble [15 × 7]&gt; ## 3 Wiltz &lt;tibble [15 × 7]&gt; This creates a tibble with two columns, division and data, where each individual (or commune in this case) is another tibble with all the original variables. This is very useful, because now we can pass these tibbles to map2(), to generate the plots. But why map2() and what’s the difference with map()? map2() works the same way as map(), but maps over two inputs: numbers1 = list(1, 2, 3, 4, 5) numbers2 = list(9, 8, 7, 6, 5) map2(numbers1, numbers2, `*`) ## [[1]] ## [1] 9 ## ## [[2]] ## [1] 16 ## ## [[3]] ## [1] 21 ## ## [[4]] ## [1] 24 ## ## [[5]] ## [1] 25 In our example with the graphs, the two inputs are the data, and the names of the communes. This is useful to create the title with labs(title = paste(&quot;Unemployment in&quot;, .y)))) where .y is the second input of map2(), the commune names contained in variable division. So what happened? We now have a tibble called plots_tibble that looks like this: print(plots_tibble) ## # A tibble: 3 x 3 ## division data plot ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 Esch-sur-Alzette &lt;tibble [15 × 7]&gt; &lt;S3: gg&gt; ## 2 Luxembourg &lt;tibble [15 × 7]&gt; &lt;S3: gg&gt; ## 3 Wiltz &lt;tibble [15 × 7]&gt; &lt;S3: gg&gt; This tibble contains three columns, division, data and now a new one called plot, that we created before using the last line mutate(plot = ...) (remember that mutate() adds columns to tibbles). plot is a list-column, with elements… being plots! Yes you read that right, the elements of the column plot are literally plots. This is what I meant with list columns. Let’s see what is inside the data and the plot columns exactly: plots_tibble %&gt;% pull(data) ## [[1]] ## # A tibble: 15 x 7 ## year active_populati… of_which_non_wa… of_which_wage_e… ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2001 11.3 665 10.1 ## 2 2002 11.7 677 10.3 ## 3 2003 11.7 674 10.2 ## 4 2004 12.2 659 10.6 ## 5 2005 11.9 654 10.3 ## 6 2006 12.2 657 10.5 ## 7 2007 12.6 634 10.9 ## 8 2008 12.9 638 11.0 ## 9 2009 13.2 652 11.0 ## 10 2010 13.6 638 11.2 ## 11 2011 13.9 630 11.5 ## 12 2012 14.3 684 11.8 ## 13 2013 14.8 694 12.0 ## 14 2014 15.2 703 12.5 ## 15 2015 15.3 710 12.6 ## # ... with 3 more variables: total_employed_population &lt;dbl&gt;, ## # unemployed &lt;dbl&gt;, unemployment_rate_in_percent &lt;dbl&gt; ## ## [[2]] ## # A tibble: 15 x 7 ## year active_populati… of_which_non_wa… of_which_wage_e… ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2001 34.4 2.89 30.4 ## 2 2002 34.8 2.94 30.3 ## 3 2003 35.2 3.03 30.1 ## 4 2004 35.6 3.06 30.1 ## 5 2005 35.6 3.13 29.8 ## 6 2006 35.5 3.12 30.3 ## 7 2007 36.1 3.25 31.1 ## 8 2008 37.5 3.39 31.9 ## 9 2009 37.9 3.49 31.6 ## 10 2010 38.6 3.54 32.1 ## 11 2011 40.3 3.66 33.6 ## 12 2012 41.8 3.81 34.6 ## 13 2013 43.4 3.98 35.5 ## 14 2014 44.6 4.11 36.7 ## 15 2015 45.2 4.14 37.5 ## # ... with 3 more variables: total_employed_population &lt;dbl&gt;, ## # unemployed &lt;dbl&gt;, unemployment_rate_in_percent &lt;dbl&gt; ## ## [[3]] ## # A tibble: 15 x 7 ## year active_populati… of_which_non_wa… of_which_wage_e… ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2001 2.13 223 1.79 ## 2 2002 2.14 220 1.78 ## 3 2003 2.18 223 1.79 ## 4 2004 2.24 227 1.85 ## 5 2005 2.26 229 1.85 ## 6 2006 2.20 206 1.82 ## 7 2007 2.27 198 1.88 ## 8 2008 2.30 200 1.90 ## 9 2009 2.36 201 1.94 ## 10 2010 2.42 195 1.97 ## 11 2011 2.48 190 2.02 ## 12 2012 2.59 188 2.10 ## 13 2013 2.66 195 2.15 ## 14 2014 2.69 185 2.19 ## 15 2015 2.77 180 2.27 ## # ... with 3 more variables: total_employed_population &lt;dbl&gt;, ## # unemployed &lt;dbl&gt;, unemployment_rate_in_percent &lt;dbl&gt; each element of data is a tibble for the specific country with columns year, active_population, etc, the original columns. But obviously, there is no division column. So to plot the data, and join all the dots together, we need to add group = 1 in the call to ggplot2() (whereas if you plot multiple lines in the same graph, you need to write group = division). But more interestingly, how can you actually see the plots? If you want to simply look at them, it is enough to use pull(): plots_tibble %&gt;% pull(plot) ## [[1]] ## ## [[2]] ## ## [[3]] And if we want to save these plots, we can do so using map2(): map2(paste0(plots_tibble$division, &quot;.pdf&quot;), plots_tibble$plot, ggsave) Saving 7 x 5 in image Saving 6.01 x 3.94 in image Saving 6.01 x 3.94 in image This was probably the most advanced topic we have studied yet; but you probably agree with me that it is among the most useful ones. This section is a perfect illustration of the power of functional programming; you can mix and match functions as long as you give them the correct arguments. You can pass data to functions that use data and then pass these functions to other functions that use functions as arguments, such as map().2 map() does not care if the functions you pass to it produces tables, graphs or even another function. map() will simply map this function to a list of inputs, and as long as these inputs are correct arguments to the function, map() will do its magic. If you combine this with list-columns, you can even use map() alongside dplyr functions and map your function by first grouping, filtering, etc… 9.8 Functional programming and modeling 9.8.1 Bootstrapping The broom package includes a bootstrap() function that allows you to resample your data with replacement and estimate your model on each sample. A worked example is available in one of the package’s Vignette. R also includes a more general boot() function, but we are going to learn about this one later, as it involves some programming. Let’s go back to model_log, and try to get bootstrapped confidence intervals (as shown in the Vignette I linked above): boot_result &lt;- Housing %&gt;% bootstrap(50) %&gt;% do(tidy(lm(log(price) ~ bedrooms + driveway, data = .))) I just use 2 variables to make the output smaller. Let’s take a look at boot_result: print(boot_result) ## # A tibble: 150 x 6 ## # Groups: replicate [50] ## replicate term estimate std.error statistic p.value ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 (Intercept) 10.2 0.0669 152. 0. ## 2 1 bedrooms 0.193 0.0191 10.1 3.41e-22 ## 3 1 drivewayyes 0.341 0.0371 9.17 9.41e-19 ## 4 2 (Intercept) 10.1 0.0710 142. 0. ## 5 2 bedrooms 0.223 0.0199 11.2 2.72e-26 ## 6 2 drivewayyes 0.353 0.0403 8.74 2.81e-17 ## 7 3 (Intercept) 10.2 0.0652 157. 0. ## 8 3 bedrooms 0.195 0.0186 10.5 1.38e-23 ## 9 3 drivewayyes 0.319 0.0358 8.90 8.39e-18 ## 10 4 (Intercept) 10.2 0.0701 146. 0. ## # ... with 140 more rows boot_result is a tibble grouped by the new variable replicate. Now it is easy to compute confidence intervals for the parameters: boot_result %&gt;% group_by(term) %&gt;% summarize(low = quantile(estimate, .05/2), high = quantile(estimate, 1 - .05/2)) ## # A tibble: 3 x 3 ## term low high ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 10.1 10.3 ## 2 bedrooms 0.158 0.221 ## 3 drivewayyes 0.306 0.434 quantile() is a built-in function that returns the quantile at the \\(alpha\\) level for a given vector (in this case the vector of estimates). Of course, we had to group by term first, as we need to compute the confidence intervals, for each terms (or estimated parameters) separately. Plotting the densities of the bootstrapped parameters might also prove interesting: ggplot(boot_result, aes(estimate)) + geom_density() + facet_wrap(~term, scales = &quot;free&quot;) 9.8.2 Cross-validation To do cross-validation, we are going to use the modelr package, which is also part of the tidyverse.3 library(modelr) modelr includes two functions for cross-validation, crossv_kfold and crossv_mc, which do K-fold Cross-Validation and Monte Carlo Cross-Validation respectively. First, let’s see what cross_mc() (cross_kfold()) returns when applied to data: cv_Housing = Housing %&gt;% crossv_mc(n = 50) print(cv_Housing) ## # A tibble: 50 x 3 ## train test .id ## &lt;list&gt; &lt;list&gt; &lt;chr&gt; ## 1 &lt;S3: resample&gt; &lt;S3: resample&gt; 01 ## 2 &lt;S3: resample&gt; &lt;S3: resample&gt; 02 ## 3 &lt;S3: resample&gt; &lt;S3: resample&gt; 03 ## 4 &lt;S3: resample&gt; &lt;S3: resample&gt; 04 ## 5 &lt;S3: resample&gt; &lt;S3: resample&gt; 05 ## 6 &lt;S3: resample&gt; &lt;S3: resample&gt; 06 ## 7 &lt;S3: resample&gt; &lt;S3: resample&gt; 07 ## 8 &lt;S3: resample&gt; &lt;S3: resample&gt; 08 ## 9 &lt;S3: resample&gt; &lt;S3: resample&gt; 09 ## 10 &lt;S3: resample&gt; &lt;S3: resample&gt; 10 ## # ... with 40 more rows This is a tibble with 3 colmuns, two of them being list-columns; train and test. Each element of train and test is a resampled tibble of the original data. This means that we can now estimate our first model (the simple linear one) on each resampled data using map(): Now if we want to estimate all these models: cv_models = cv_Housing %&gt;% mutate(model = map(train, ~lm(price ~ ., data = .))) print(cv_models) ## # A tibble: 50 x 4 ## train test .id model ## &lt;list&gt; &lt;list&gt; &lt;chr&gt; &lt;list&gt; ## 1 &lt;S3: resample&gt; &lt;S3: resample&gt; 01 &lt;S3: lm&gt; ## 2 &lt;S3: resample&gt; &lt;S3: resample&gt; 02 &lt;S3: lm&gt; ## 3 &lt;S3: resample&gt; &lt;S3: resample&gt; 03 &lt;S3: lm&gt; ## 4 &lt;S3: resample&gt; &lt;S3: resample&gt; 04 &lt;S3: lm&gt; ## 5 &lt;S3: resample&gt; &lt;S3: resample&gt; 05 &lt;S3: lm&gt; ## 6 &lt;S3: resample&gt; &lt;S3: resample&gt; 06 &lt;S3: lm&gt; ## 7 &lt;S3: resample&gt; &lt;S3: resample&gt; 07 &lt;S3: lm&gt; ## 8 &lt;S3: resample&gt; &lt;S3: resample&gt; 08 &lt;S3: lm&gt; ## 9 &lt;S3: resample&gt; &lt;S3: resample&gt; 09 &lt;S3: lm&gt; ## 10 &lt;S3: resample&gt; &lt;S3: resample&gt; 10 &lt;S3: lm&gt; ## # ... with 40 more rows We added a list-column with the 50 models estimated (or trained) on the train data. Now we can compute, say, the RMSE from before on each one. modelr includes a rmse() function, so unlike in the previous section where we computed the RMSE manually we are simply going to use this function: rmse_cv = cv_models %&gt;% mutate(rmse_all_models = map2_dbl(model, test, ~rmse(.x, .y))) %&gt;% pull(rmse_all_models) print(rmse_cv) ## [1] 15171.92 16841.92 16079.78 14742.20 19402.36 15447.63 16008.31 ## [8] 14100.36 16214.12 16231.63 15604.84 14668.40 13607.35 17193.01 ## [15] 14831.43 17529.64 13515.38 14149.88 16379.39 16190.14 17660.06 ## [22] 16422.06 17507.19 15417.58 15808.34 17325.15 17431.91 14366.48 ## [29] 18576.72 15887.49 13806.53 16023.93 14236.07 14947.74 14631.10 ## [36] 14779.07 14961.96 15758.44 14804.29 13970.20 17106.22 16949.19 ## [43] 15672.91 15870.72 15272.37 14247.79 15180.60 18577.50 15049.53 ## [50] 13451.04 We can now compute the mean of this rmse_cv variable: cv_rmse_lin_lin = mean(rmse_cv) which is equal to 1.571219710^{4}. For the log-lin model, this is a bit more complicated, because we need to exponentiate the predictions. However, if we use rmse() as before, there is no way to do that. I show you how you can do that, but it involves a few more steps than simply using rmse(). Try to understand the code below that computes the bootstrapped rmse for the log-lin model. You can see this as an advanced exercise; if you understand these next lines of code, you should understand anything that has to do with the tidyverse. cv_rmse_log_lin = cv_Housing %&gt;% mutate(model = map(train, ~lm(log(price) ~ ., data = .))) %&gt;% mutate(log_pred = map2(model, test, ~exp(predict(.x, .y)))) %&gt;% mutate(prices = map(test, ~as.data.frame(.x)$price)) %&gt;% mutate( rmse_all = map2_dbl(log_pred, prices, ~sqrt(mean((.x - .y)**2, na.rm = TRUE)))) %&gt;% pull(rmse_all) %&gt;% mean() cv_rmse_log_lin is equal to 1.54912610^{4}, which is lower than in the lin-lin model. 9.9 Exercises Suppose you have an Excel workbook that contains data on three sheets. Create a function that reads entire workbooks, and that returns a list of tibbles, where each tibble is the data of one sheet (download the example Excel workbook, example_workbook.xlsx, from the assets folder on the books github). Use one of the map() functions to combine two lists into one. Consider the following two lists: mediterranean &lt;- list(&quot;starters&quot; = list(&quot;humous&quot;, &quot;lasagna&quot;), &quot;dishes&quot; = list(&quot;sardines&quot;, &quot;olives&quot;)) continental &lt;- list(&quot;starters&quot; = list(&quot;pea soup&quot;, &quot;terrine&quot;), &quot;dishes&quot; = list(&quot;frikadelle&quot;, &quot;sauerkraut&quot;)) The result we’d like to have would look like this: $starters $starters[[1]] [1] &quot;humous&quot; $starters[[2]] [1] &quot;olives&quot; $starters[[3]] [1] &quot;pea soup&quot; $starters[[4]] [1] &quot;terrine&quot; $dishes $dishes[[1]] [1] &quot;sardines&quot; $dishes[[2]] [1] &quot;lasagna&quot; $dishes[[3]] [1] &quot;frikadelle&quot; $dishes[[4]] [1] &quot;sauerkraut&quot; This is simply the + operator you’re used to. Try this out: `+`(1, 5) and you’ll see + is a function like any other. You just have to write backticks around the plus symbol to make it work.↩ Functions that have other functions as input are called higher order functions↩ This package is still somewhat young and experimental and might get replaced by two others in the future. At some point in the future you might get a warning message telling you that the package is deprecated. When this happens, you would need to switch to the new packages, but transition should be fairly easy.↩ "]
]
