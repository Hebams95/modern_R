[
["data-manipulation-and-descriptive-statistics.html", "Chapter 5 Data manipulation and descriptive statistics 5.1 Smoking is bad for you, but pipes are your friend 5.2 The {tidyverse}’s enfant prodige: {dplyr} 5.3 Reshaping data with tidyr 5.4 Getting to know factor variables 5.5 Scoped {tidyverse} verbs 5.6 Working with a list of datasets 5.7 List-columns 5.8 Exercises", " Chapter 5 Data manipulation and descriptive statistics Now that we are familiar with some R objects and know how to import data, it is time to write some code. In this chapter, we are going to compute descriptive statistics for a single dataset, but also for a list of datasets. However, I will not give a list of functions to compute descriptive statistics; if you need a specific function you can find easily in the Help pane in Rstudio or using any modern internet search engine. What I will do is show you a workflow that allows you to compute the statisics you need fast. R has a lot of built-in functions for descriptive statistics; however, if you want to compute statistics by, say, gender, some more complex manipulations are needed. At least this was true in the past. Nowadays, thanks to the packages from the tidyverse, it is very easy and fast to compute descriptive statistics by any stratifying variable(s). The packages we are going to use for this are called dplyr and tidyr. dplyr contains a lot of functions that make manipulating data and computing descriptive statistics very easy. To make things easier for now, we are going to use example data included with dplyr. So no need to import an external dataset; this does not change anything to the example that we are going to study here; the source of the data does not matter for this. tidyr is very useful to reshape data. We are going to focus on two functions from tidyr, gather() and spread(). But first, let’s learn about pipes. 5.1 Smoking is bad for you, but pipes are your friend The title of this section might sound weird at first, but by the end of it, you’ll get this (terrible) pun. You probably know the following painting by René Magritte, La trahison des images: knitr::include_graphics(&quot;assets/pas_une_pipe.png&quot;) It turns out there’s an R package from the tidyverse that is called magrittr. What does this package do? It brings pipes to R. Pipes are a concept from the Unix operating system; if you’re using a GNU+Linux distribution or macOS, you’re basically using a modern unix (that’s an oversimplification, but I’m an economist by training, and outrageously oversimplifying things is what we do, deal with it). The idea of pipes is to take the output of a command, and feed it as the input of another command. The magrittr package brings pipes to R, by using the weird looking %&gt;%. Try the following: library(magrittr) 16 %&gt;% sqrt ## [1] 4 Super weird right? But you probably understand what happened; 16 got fed as the first argument of the function sqrt(). You can chain multiple functions: 16 %&gt;% sqrt %&gt;% `+`(18) ## [1] 22 The output of 16 (16) got fed to sqrt(), and the output of sqrt(16) (4) got fed to +(18) (22). Without %&gt;% you’d write the line just above like this: sqrt(16) + 18 ## [1] 22 It might not be very clear right now why this is useful, but the %&gt;% is probably one of the infix operators, because when using packages from the tidyverse, you will naturally want to chain a lot of functions together. Without the %&gt;% it would become messy very fast. %&gt;% is not the only pipe operator in magrittr. There’s %T%, %&lt;&gt;% and %$%. All have their uses, but are basically shortcuts to some common tasks with %&gt;% plus another function. Which means that you can live without them, and because of this, I will only discuss them briefly once we’ll have learned about the other tidyverse packages. 5.2 The {tidyverse}’s enfant prodige: {dplyr} 5.2.1 A first taste of data manipulation with {dplyr} First, let’s load dplyr and the included starwars dataset. Let’s also take a look at the first 5 lines of the dataset: library(dplyr) data(starwars) head(starwars) ## # A tibble: 6 x 13 ## name height mass hair_color skin_color eye_color birth_year gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Luke… 172 77 blond fair blue 19 male ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 &lt;NA&gt; ## 3 R2-D2 96 32 &lt;NA&gt; white, bl… red 33 &lt;NA&gt; ## 4 Dart… 202 136 none white yellow 41.9 male ## 5 Leia… 150 49 brown light brown 19 female ## 6 Owen… 178 120 brown, gr… light blue 52 male ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; data(starwars) loads the example dataset called starwars that is included in the package dplyr. As I said earlier, this is just an example; you could have loaded an external dataset, from a .csv file for instance. This does not matter for what comes next. R includes a lot of functions for descriptive statistics, such as mean(), sd(), cov(), and many more. What dplyr brings to the table (among other niceties) is the possibility to apply these functions to the dataset easily. For example, imagine you want the average height of everyone in the dataset. Using the basic R functions, you could write this: mean(starwars$height) ## [1] NA starwars$height means that the user wants to access the column called height from the dataset starwars. Remember that the $ symbol is how you access elements of a named list. This is the same for columns of datasets as you can see. This is then given as an argument to the function mean(). But what if the user wants the average height by species? Before dplyr, a solution to this simple problem would have required more than a single command. Now this is as easy as: starwars %&gt;% group_by(species) %&gt;% summarise(mean(height)) ## # A tibble: 38 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79 ## 2 Besalisk 198 ## 3 Cerean 198 ## 4 Chagrian 196 ## 5 Clawdite 168 ## 6 Droid NA ## 7 Dug 112 ## 8 Ewok 88 ## 9 Geonosian 183 ## 10 Gungan 209. ## # ... with 28 more rows The usefulness of the %&gt;% (pipe operator) becomes apparent now. Without it, one would write instead: summarise(group_by(starwars, species), mean(height)) ## # A tibble: 38 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79 ## 2 Besalisk 198 ## 3 Cerean 198 ## 4 Chagrian 196 ## 5 Clawdite 168 ## 6 Droid NA ## 7 Dug 112 ## 8 Ewok 88 ## 9 Geonosian 183 ## 10 Gungan 209. ## # ... with 28 more rows as you can clearly see, it is much more difficult to read. Imagine now that I want the average height by species, but only for males. Again, this is very easy using %&gt;%: starwars %&gt;% filter(gender == &quot;male&quot;) %&gt;% group_by(species) %&gt;% summarise(mean(height)) ## # A tibble: 32 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79 ## 2 Besalisk 198 ## 3 Cerean 198 ## 4 Chagrian 196 ## 5 Dug 112 ## 6 Ewok 88 ## 7 Geonosian 183 ## 8 Gungan 209. ## 9 Human NA ## 10 Iktotchi 188 ## # ... with 22 more rows Again, the %&gt;% makes the above lines of code very easy to read. Without it, one would need to write: summarise(group_by(filter(starwars, gender == &quot;male&quot;), species), mean(height)) ## # A tibble: 32 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79 ## 2 Besalisk 198 ## 3 Cerean 198 ## 4 Chagrian 196 ## 5 Dug 112 ## 6 Ewok 88 ## 7 Geonosian 183 ## 8 Gungan 209. ## 9 Human NA ## 10 Iktotchi 188 ## # ... with 22 more rows I think you agree with me that this is not very readable. Once you’re used to %&gt;%, you won’t go back to not use it. To make things clearer; filter(), group_by() and summarise() are functions that are included in dplyr. %&gt;% is actually a function from magrittr, but this package gets loaded on the fly when you load dplyr, so you do not need to worry about it. mean() is a function native to R. The result of all these operations that use dplyr functions are actually other datasets, or tibbles. This means that you can save them in variable, and then work with these as any other datasets. mean_height = starwars %&gt;% group_by(species) %&gt;% summarise(mean(height)) class(mean_height) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; head(mean_height) ## # A tibble: 6 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79 ## 2 Besalisk 198 ## 3 Cerean 198 ## 4 Chagrian 196 ## 5 Clawdite 168 ## 6 Droid NA You could then write this data to disk using rio::export() for instance. If you need more than the mean of the height, you can keep adding as many functions as needed: summary_table = starwars %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height), var_height = var(height), n_obs = n()) print(summary_table) ## # A tibble: 38 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Aleena 79 NA 1 ## 2 Besalisk 198 NA 1 ## 3 Cerean 198 NA 1 ## 4 Chagrian 196 NA 1 ## 5 Clawdite 168 NA 1 ## 6 Droid NA NA 5 ## 7 Dug 112 NA 1 ## 8 Ewok 88 NA 1 ## 9 Geonosian 183 NA 1 ## 10 Gungan 209. 201. 3 ## # ... with 28 more rows I’ve added more functions, namely var(), to get the variance of height, and n(), which is a function from dplyr, not base R, to get the number of observations. This is quite useful, because we see that for a lot of species we only have one single individual! Let’s focus on the species for which we have more than 1 individual. Since we save all the previous operations (which produce a tibble) in a variable, we can keep going from there: summary_table2 = summary_table %&gt;% filter(n_obs &gt; 1) print(summary_table2) ## # A tibble: 9 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid NA NA 5 ## 2 Gungan 209. 201. 3 ## 3 Human NA NA 35 ## 4 Kaminoan 221 128 2 ## 5 Mirialan 168 8 2 ## 6 Twi&#39;lek 179 2 2 ## 7 Wookiee 231 18 2 ## 8 Zabrak 173 8 2 ## 9 &lt;NA&gt; NA NA 5 There’s a lot of NAs; this is because by default, mean() and var() return NA if even one single observation is NA. This is good, because it forces you to look at the data to see what is going on. If you would get a number, even if there were NAs you could very easily miss these missing values. It is better for functions to fail early and often than the opposite. mean() and var() have a na.rm option that the user can set to TRUE to get the result by ignoring the NAs: starwars %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height, na.rm = TRUE), var_height = var(height, na.rm = TRUE), n_obs = n()) %&gt;% filter(n_obs &gt; 1) ## # A tibble: 9 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid 140 2705. 5 ## 2 Gungan 209. 201. 3 ## 3 Human 177. 157. 35 ## 4 Kaminoan 221 128 2 ## 5 Mirialan 168 8 2 ## 6 Twi&#39;lek 179 2 2 ## 7 Wookiee 231 18 2 ## 8 Zabrak 173 8 2 ## 9 &lt;NA&gt; 160 1826 5 In the code above, I have combined the two previous steps to get the result I’m interested in. There’s a line in the final output that says NA for the species. Let’s go back to the raw data and find these lines: starwars %&gt;% filter(is.na(species)) ## # A tibble: 5 x 13 ## name height mass hair_color skin_color eye_color birth_year gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Ric … 183 NA brown fair blue NA male ## 2 Quar… 183 NA black dark brown 62 male ## 3 R4-P… 96 NA none silver, r… red, blue NA female ## 4 Sly … 178 48 none pale white NA female ## 5 Capt… NA NA unknown unknown unknown NA female ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; To test for NA, one uses the function is.na() not something like species == &quot;NA&quot; or anything like that.!is.na() does the opposite: starwars %&gt;% filter(!is.na(species)) ## # A tibble: 82 x 13 ## name height mass hair_color skin_color eye_color birth_year gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Luke… 172 77 blond fair blue 19 male ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 &lt;NA&gt; ## 3 R2-D2 96 32 &lt;NA&gt; white, bl… red 33 &lt;NA&gt; ## 4 Dart… 202 136 none white yellow 41.9 male ## 5 Leia… 150 49 brown light brown 19 female ## 6 Owen… 178 120 brown, gr… light blue 52 male ## 7 Beru… 165 75 brown light blue 47 female ## 8 R5-D4 97 32 &lt;NA&gt; white, red red NA &lt;NA&gt; ## 9 Bigg… 183 84 black light brown 24 male ## 10 Obi-… 182 77 auburn, w… fair blue-gray 57 male ## # ... with 72 more rows, and 5 more variables: homeworld &lt;chr&gt;, ## # species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; The ! function negates a predicate function (a predicate function is a function that returns TRUE or FALSE). We can then rerun our analysis from before: starwars %&gt;% filter(!is.na(species)) %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height, na.rm = TRUE), var_height = var(height, na.rm = TRUE), n_obs = n()) %&gt;% filter(n_obs &gt; 1) ## # A tibble: 8 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid 140 2705. 5 ## 2 Gungan 209. 201. 3 ## 3 Human 177. 157. 35 ## 4 Kaminoan 221 128 2 ## 5 Mirialan 168 8 2 ## 6 Twi&#39;lek 179 2 2 ## 7 Wookiee 231 18 2 ## 8 Zabrak 173 8 2 And why not compute the same table, but first add another stratifying variable? starwars %&gt;% filter(!is.na(species)) %&gt;% group_by(species, gender) %&gt;% summarise(ave_height = mean(height, na.rm = TRUE), var_height = var(height, na.rm = TRUE), n_obs = n()) %&gt;% filter(n_obs &gt; 1) ## # A tibble: 8 x 5 ## # Groups: species [6] ## species gender ave_height var_height n_obs ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid none 200 NA 2 ## 2 Droid &lt;NA&gt; 120 1657 3 ## 3 Gungan male 209. 201. 3 ## 4 Human female 160. 48.8 9 ## 5 Human male 182. 67.1 26 ## 6 Mirialan female 168 8 2 ## 7 Wookiee male 231 18 2 ## 8 Zabrak male 173 8 2 Ok, that’s it for a first taste. We have already discovered some very useful {dplyr} functions, filter(), group_by() and summarise summarise(). Now, we are going to learn more about these functions in more detail. 5.2.2 Filter the rows of a dataset with filter() We’re going to use the Gasoline dataset from the plm package, so install that first: install.packages(&quot;plm&quot;) Then load the required data: data(Gasoline, package = &quot;plm&quot;) and load dplyr: library(dplyr) This dataset gives the consumption of gasoline for 18 countries from 1960 to 1978. When you load the data like this, it is a standard data.frame. dplyr functions can be used on standard data.frame objects, but just because we learned about tibble’s, let’s convert the data to a tibble and change its name: gasoline &lt;- as_tibble(Gasoline) filter() is pretty straightforward. What if you would like to subset the data to focus on the year 1969? Simple: filter(gasoline, year == 1969) ## # A tibble: 18 x 6 ## country year lgaspcar lincomep lrpmg lcarpcap ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## 2 BELGIUM 1969 3.85 -5.86 -0.355 -8.52 ## 3 CANADA 1969 4.86 -5.56 -1.04 -8.10 ## 4 DENMARK 1969 4.17 -5.72 -0.407 -8.47 ## 5 FRANCE 1969 3.77 -5.84 -0.315 -8.37 ## 6 GERMANY 1969 3.90 -5.83 -0.589 -8.44 ## 7 GREECE 1969 4.89 -6.59 -0.180 -10.7 ## 8 IRELAND 1969 4.21 -6.38 -0.272 -8.95 ## 9 ITALY 1969 3.74 -6.28 -0.248 -8.67 ## 10 JAPAN 1969 4.52 -6.16 -0.417 -9.61 ## 11 NETHERLA 1969 3.99 -5.88 -0.417 -8.63 ## 12 NORWAY 1969 4.09 -5.74 -0.338 -8.69 ## 13 SPAIN 1969 3.99 -5.60 0.669 -9.72 ## 14 SWEDEN 1969 3.99 -7.77 -2.73 -8.20 ## 15 SWITZERL 1969 4.21 -5.91 -0.918 -8.47 ## 16 TURKEY 1969 5.72 -7.39 -0.298 -12.5 ## 17 U.K. 1969 3.95 -6.03 -0.383 -8.47 ## 18 U.S.A. 1969 4.84 -5.41 -1.22 -7.79 Remember the pipe operator, %&gt;% from the start of this chapter? Here’s how this would work with it: gasoline %&gt;% filter(year == 1969) ## # A tibble: 18 x 6 ## country year lgaspcar lincomep lrpmg lcarpcap ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## 2 BELGIUM 1969 3.85 -5.86 -0.355 -8.52 ## 3 CANADA 1969 4.86 -5.56 -1.04 -8.10 ## 4 DENMARK 1969 4.17 -5.72 -0.407 -8.47 ## 5 FRANCE 1969 3.77 -5.84 -0.315 -8.37 ## 6 GERMANY 1969 3.90 -5.83 -0.589 -8.44 ## 7 GREECE 1969 4.89 -6.59 -0.180 -10.7 ## 8 IRELAND 1969 4.21 -6.38 -0.272 -8.95 ## 9 ITALY 1969 3.74 -6.28 -0.248 -8.67 ## 10 JAPAN 1969 4.52 -6.16 -0.417 -9.61 ## 11 NETHERLA 1969 3.99 -5.88 -0.417 -8.63 ## 12 NORWAY 1969 4.09 -5.74 -0.338 -8.69 ## 13 SPAIN 1969 3.99 -5.60 0.669 -9.72 ## 14 SWEDEN 1969 3.99 -7.77 -2.73 -8.20 ## 15 SWITZERL 1969 4.21 -5.91 -0.918 -8.47 ## 16 TURKEY 1969 5.72 -7.39 -0.298 -12.5 ## 17 U.K. 1969 3.95 -6.03 -0.383 -8.47 ## 18 U.S.A. 1969 4.84 -5.41 -1.22 -7.79 So gasoline, which is a tibble object, is passed as the first argument of the filter() function. Starting now, we’re only going to use these pipes. You will see why soon enough, so bear with me. You can also filter more than just one year, by using the %in% operator: gasoline %&gt;% filter(year %in% seq(1969, 1973)) ## # A tibble: 90 x 6 ## country year lgaspcar lincomep lrpmg lcarpcap ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## 2 AUSTRIA 1970 4.08 -6.08 -0.597 -8.73 ## 3 AUSTRIA 1971 4.11 -6.04 -0.654 -8.64 ## 4 AUSTRIA 1972 4.13 -5.98 -0.596 -8.54 ## 5 AUSTRIA 1973 4.20 -5.90 -0.594 -8.49 ## 6 BELGIUM 1969 3.85 -5.86 -0.355 -8.52 ## 7 BELGIUM 1970 3.87 -5.80 -0.378 -8.45 ## 8 BELGIUM 1971 3.87 -5.76 -0.399 -8.41 ## 9 BELGIUM 1972 3.91 -5.71 -0.311 -8.36 ## 10 BELGIUM 1973 3.90 -5.64 -0.373 -8.31 ## # ... with 80 more rows or even non-consecutive years: gasoline %&gt;% filter(year %in% c(1969, 1973, 1977)) ## # A tibble: 54 x 6 ## country year lgaspcar lincomep lrpmg lcarpcap ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## 2 AUSTRIA 1973 4.20 -5.90 -0.594 -8.49 ## 3 AUSTRIA 1977 3.93 -5.83 -0.422 -8.25 ## 4 BELGIUM 1969 3.85 -5.86 -0.355 -8.52 ## 5 BELGIUM 1973 3.90 -5.64 -0.373 -8.31 ## 6 BELGIUM 1977 3.85 -5.56 -0.432 -8.14 ## 7 CANADA 1969 4.86 -5.56 -1.04 -8.10 ## 8 CANADA 1973 4.90 -5.41 -1.13 -7.94 ## 9 CANADA 1977 4.81 -5.34 -1.07 -7.77 ## 10 DENMARK 1969 4.17 -5.72 -0.407 -8.47 ## # ... with 44 more rows %in% tests if an object is part of a set. 5.2.3 Select columns with select() While filter() and its scoped versions allow you to keep or discard rows of data, select() (and its scoped versions) allow you to keep or discard entire columns. To keep columns: gasoline %&gt;% select(country, year, lrpmg) ## # A tibble: 342 x 3 ## country year lrpmg ## * &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 AUSTRIA 1960 -0.335 ## 2 AUSTRIA 1961 -0.351 ## 3 AUSTRIA 1962 -0.380 ## 4 AUSTRIA 1963 -0.414 ## 5 AUSTRIA 1964 -0.445 ## 6 AUSTRIA 1965 -0.497 ## 7 AUSTRIA 1966 -0.467 ## 8 AUSTRIA 1967 -0.506 ## 9 AUSTRIA 1968 -0.522 ## 10 AUSTRIA 1969 -0.559 ## # ... with 332 more rows To discard them: gasoline %&gt;% select(-country, -year, -lrpmg) ## # A tibble: 342 x 3 ## lgaspcar lincomep lcarpcap ## * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.17 -6.47 -9.77 ## 2 4.10 -6.43 -9.61 ## 3 4.07 -6.41 -9.46 ## 4 4.06 -6.37 -9.34 ## 5 4.04 -6.32 -9.24 ## 6 4.03 -6.29 -9.12 ## 7 4.05 -6.25 -9.02 ## 8 4.05 -6.23 -8.93 ## 9 4.05 -6.21 -8.85 ## 10 4.05 -6.15 -8.79 ## # ... with 332 more rows To rename them: gasoline %&gt;% select(country, date = year, lrpmg) ## # A tibble: 342 x 3 ## country date lrpmg ## * &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 AUSTRIA 1960 -0.335 ## 2 AUSTRIA 1961 -0.351 ## 3 AUSTRIA 1962 -0.380 ## 4 AUSTRIA 1963 -0.414 ## 5 AUSTRIA 1964 -0.445 ## 6 AUSTRIA 1965 -0.497 ## 7 AUSTRIA 1966 -0.467 ## 8 AUSTRIA 1967 -0.506 ## 9 AUSTRIA 1968 -0.522 ## 10 AUSTRIA 1969 -0.559 ## # ... with 332 more rows There’s also rename(), but it works a bit differently: gasoline %&gt;% rename(date = year) ## # A tibble: 342 x 6 ## country date lgaspcar lincomep lrpmg lcarpcap ## * &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1960 4.17 -6.47 -0.335 -9.77 ## 2 AUSTRIA 1961 4.10 -6.43 -0.351 -9.61 ## 3 AUSTRIA 1962 4.07 -6.41 -0.380 -9.46 ## 4 AUSTRIA 1963 4.06 -6.37 -0.414 -9.34 ## 5 AUSTRIA 1964 4.04 -6.32 -0.445 -9.24 ## 6 AUSTRIA 1965 4.03 -6.29 -0.497 -9.12 ## 7 AUSTRIA 1966 4.05 -6.25 -0.467 -9.02 ## 8 AUSTRIA 1967 4.05 -6.23 -0.506 -8.93 ## 9 AUSTRIA 1968 4.05 -6.21 -0.522 -8.85 ## 10 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## # ... with 332 more rows rename() does not do any kind of selection, but just renames. To re-order them: gasoline %&gt;% select(year, country, lrpmg, everything()) ## # A tibble: 342 x 6 ## year country lrpmg lgaspcar lincomep lcarpcap ## * &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1960 AUSTRIA -0.335 4.17 -6.47 -9.77 ## 2 1961 AUSTRIA -0.351 4.10 -6.43 -9.61 ## 3 1962 AUSTRIA -0.380 4.07 -6.41 -9.46 ## 4 1963 AUSTRIA -0.414 4.06 -6.37 -9.34 ## 5 1964 AUSTRIA -0.445 4.04 -6.32 -9.24 ## 6 1965 AUSTRIA -0.497 4.03 -6.29 -9.12 ## 7 1966 AUSTRIA -0.467 4.05 -6.25 -9.02 ## 8 1967 AUSTRIA -0.506 4.05 -6.23 -8.93 ## 9 1968 AUSTRIA -0.522 4.05 -6.21 -8.85 ## 10 1969 AUSTRIA -0.559 4.05 -6.15 -8.79 ## # ... with 332 more rows everything() is another of those helper functions (like starts_with(), and ends_with()). 5.2.4 Group the observations of your dataset with group_by() group_by() is a very useful verb; as the name implies, it allows you to create groups and then, for example, compute descriptive statistics by groups. For example, let’s group our data by country: gasoline %&gt;% group_by(country) ## # A tibble: 342 x 6 ## # Groups: country [18] ## country year lgaspcar lincomep lrpmg lcarpcap ## * &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1960 4.17 -6.47 -0.335 -9.77 ## 2 AUSTRIA 1961 4.10 -6.43 -0.351 -9.61 ## 3 AUSTRIA 1962 4.07 -6.41 -0.380 -9.46 ## 4 AUSTRIA 1963 4.06 -6.37 -0.414 -9.34 ## 5 AUSTRIA 1964 4.04 -6.32 -0.445 -9.24 ## 6 AUSTRIA 1965 4.03 -6.29 -0.497 -9.12 ## 7 AUSTRIA 1966 4.05 -6.25 -0.467 -9.02 ## 8 AUSTRIA 1967 4.05 -6.23 -0.506 -8.93 ## 9 AUSTRIA 1968 4.05 -6.21 -0.522 -8.85 ## 10 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## # ... with 332 more rows It looks like nothing much happened, but if you look at the second line of the output you can read the following: ## # Groups: country [18] this means that the data is grouped, and every computation you will do now will take these groups into account. This will be clearer in the next subsection. It is also possible to group according to various variables: gasoline %&gt;% group_by(country, year) ## # A tibble: 342 x 6 ## # Groups: country, year [342] ## country year lgaspcar lincomep lrpmg lcarpcap ## * &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1960 4.17 -6.47 -0.335 -9.77 ## 2 AUSTRIA 1961 4.10 -6.43 -0.351 -9.61 ## 3 AUSTRIA 1962 4.07 -6.41 -0.380 -9.46 ## 4 AUSTRIA 1963 4.06 -6.37 -0.414 -9.34 ## 5 AUSTRIA 1964 4.04 -6.32 -0.445 -9.24 ## 6 AUSTRIA 1965 4.03 -6.29 -0.497 -9.12 ## 7 AUSTRIA 1966 4.05 -6.25 -0.467 -9.02 ## 8 AUSTRIA 1967 4.05 -6.23 -0.506 -8.93 ## 9 AUSTRIA 1968 4.05 -6.21 -0.522 -8.85 ## 10 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## # ... with 332 more rows and so on. You can then also ungroup: gasoline %&gt;% group_by(country, year) %&gt;% ungroup() ## # A tibble: 342 x 6 ## country year lgaspcar lincomep lrpmg lcarpcap ## * &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1960 4.17 -6.47 -0.335 -9.77 ## 2 AUSTRIA 1961 4.10 -6.43 -0.351 -9.61 ## 3 AUSTRIA 1962 4.07 -6.41 -0.380 -9.46 ## 4 AUSTRIA 1963 4.06 -6.37 -0.414 -9.34 ## 5 AUSTRIA 1964 4.04 -6.32 -0.445 -9.24 ## 6 AUSTRIA 1965 4.03 -6.29 -0.497 -9.12 ## 7 AUSTRIA 1966 4.05 -6.25 -0.467 -9.02 ## 8 AUSTRIA 1967 4.05 -6.23 -0.506 -8.93 ## 9 AUSTRIA 1968 4.05 -6.21 -0.522 -8.85 ## 10 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 ## # ... with 332 more rows 5.2.5 Get summary statistics with summarise() Ok, now that we have learned the basic verbs, we can start to do more interesting stuff. For example, one might want to compute the average gasoline consumption in each country, for the whole period: gasoline %&gt;% group_by(country) %&gt;% summarise(mean(lgaspcar)) ## # A tibble: 18 x 2 ## country `mean(lgaspcar)` ## &lt;fct&gt; &lt;dbl&gt; ## 1 AUSTRIA 4.06 ## 2 BELGIUM 3.92 ## 3 CANADA 4.86 ## 4 DENMARK 4.19 ## 5 FRANCE 3.82 ## 6 GERMANY 3.89 ## 7 GREECE 4.88 ## 8 IRELAND 4.23 ## 9 ITALY 3.73 ## 10 JAPAN 4.70 ## 11 NETHERLA 4.08 ## 12 NORWAY 4.11 ## 13 SPAIN 4.06 ## 14 SWEDEN 4.01 ## 15 SWITZERL 4.24 ## 16 TURKEY 5.77 ## 17 U.K. 3.98 ## 18 U.S.A. 4.82 mean() was given as an argument to summarise(), which is a dplyr verb. What we get is another tibble, that contains the variable we used to group, as well as the average per country. We can also rename this column: gasoline %&gt;% group_by(country) %&gt;% summarise(mean_gaspcar = mean(lgaspcar)) ## # A tibble: 18 x 2 ## country mean_gaspcar ## &lt;fct&gt; &lt;dbl&gt; ## 1 AUSTRIA 4.06 ## 2 BELGIUM 3.92 ## 3 CANADA 4.86 ## 4 DENMARK 4.19 ## 5 FRANCE 3.82 ## 6 GERMANY 3.89 ## 7 GREECE 4.88 ## 8 IRELAND 4.23 ## 9 ITALY 3.73 ## 10 JAPAN 4.70 ## 11 NETHERLA 4.08 ## 12 NORWAY 4.11 ## 13 SPAIN 4.06 ## 14 SWEDEN 4.01 ## 15 SWITZERL 4.24 ## 16 TURKEY 5.77 ## 17 U.K. 3.98 ## 18 U.S.A. 4.82 and because the output is a tibble, we can continue to use dplyr verbs on it: gasoline %&gt;% group_by(country) %&gt;% summarise(mean_gaspcar = mean(lgaspcar)) %&gt;% filter(country == &quot;FRANCE&quot;) ## # A tibble: 1 x 2 ## country mean_gaspcar ## &lt;fct&gt; &lt;dbl&gt; ## 1 FRANCE 3.82 Ok, let’s pause here. See what I did in the last example? I chained 3 dplyr verbs together with %&gt;%. Without using %&gt;% I would have written: filter( summarise( group_by(gasoline, country), mean_gaspcar = mean(lgaspcar)), country == &quot;FRANCE&quot;) ## # A tibble: 1 x 2 ## country mean_gaspcar ## &lt;fct&gt; &lt;dbl&gt; ## 1 FRANCE 3.82 I don’t know about you, but this is much more difficult to read than the version with %&gt;%. It is possible to work like that, of course, but personally, I would advise you bite the bullet and learn to love the pipe. It won’t give you cancer. Ok, back to summarise(). We can really do a lot of stuff with this verb. For example, we can compute several descriptive statistics at once: gasoline %&gt;% group_by(country) %&gt;% summarise(mean_gaspcar = mean(lgaspcar), sd_gaspcar = sd(lgaspcar), max_gaspcar = max(lgaspcar), min_gaspcar = min(lgaspcar)) ## # A tibble: 18 x 5 ## country mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 4.06 0.0693 4.20 3.92 ## 2 BELGIUM 3.92 0.103 4.16 3.82 ## 3 CANADA 4.86 0.0262 4.90 4.81 ## 4 DENMARK 4.19 0.158 4.50 4.00 ## 5 FRANCE 3.82 0.0499 3.91 3.75 ## 6 GERMANY 3.89 0.0239 3.93 3.85 ## 7 GREECE 4.88 0.255 5.38 4.48 ## 8 IRELAND 4.23 0.0437 4.33 4.16 ## 9 ITALY 3.73 0.220 4.05 3.38 ## 10 JAPAN 4.70 0.684 6.00 3.95 ## 11 NETHERLA 4.08 0.286 4.65 3.71 ## 12 NORWAY 4.11 0.123 4.44 3.96 ## 13 SPAIN 4.06 0.317 4.75 3.62 ## 14 SWEDEN 4.01 0.0364 4.07 3.91 ## 15 SWITZERL 4.24 0.102 4.44 4.05 ## 16 TURKEY 5.77 0.329 6.16 5.14 ## 17 U.K. 3.98 0.0479 4.10 3.91 ## 18 U.S.A. 4.82 0.0219 4.86 4.79 Because the output is a tibble, you can save it in a variable of course: desc_gasoline &lt;- gasoline %&gt;% group_by(country) %&gt;% summarise(mean_gaspcar = mean(lgaspcar), sd_gaspcar = sd(lgaspcar), max_gaspcar = max(lgaspcar), min_gaspcar = min(lgaspcar)) And then you can answer questions such as, which country has the maximum average gasoline consumption?: desc_gasoline %&gt;% filter(max(mean_gaspcar) == mean_gaspcar) ## # A tibble: 1 x 5 ## country mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 TURKEY 5.77 0.329 6.16 5.14 Turns out it’s Turkey. What about the minimum consumption? desc_gasoline %&gt;% filter(min(mean_gaspcar) == mean_gaspcar) ## # A tibble: 1 x 5 ## country mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ITALY 3.73 0.220 4.05 3.38 5.2.6 Adding columns with mutate() and transmute() mutate() adds a column to the tibble, which can contain any transformation of any other variable: gasoline %&gt;% group_by(country) %&gt;% mutate(n()) ## # A tibble: 342 x 7 ## # Groups: country [18] ## country year lgaspcar lincomep lrpmg lcarpcap `n()` ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 AUSTRIA 1960 4.17 -6.47 -0.335 -9.77 19 ## 2 AUSTRIA 1961 4.10 -6.43 -0.351 -9.61 19 ## 3 AUSTRIA 1962 4.07 -6.41 -0.380 -9.46 19 ## 4 AUSTRIA 1963 4.06 -6.37 -0.414 -9.34 19 ## 5 AUSTRIA 1964 4.04 -6.32 -0.445 -9.24 19 ## 6 AUSTRIA 1965 4.03 -6.29 -0.497 -9.12 19 ## 7 AUSTRIA 1966 4.05 -6.25 -0.467 -9.02 19 ## 8 AUSTRIA 1967 4.05 -6.23 -0.506 -8.93 19 ## 9 AUSTRIA 1968 4.05 -6.21 -0.522 -8.85 19 ## 10 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 19 ## # ... with 332 more rows Using mutate() I’ve added a column that counts how many times the country appears in the tibble, using n(), another dplyr function. There’s also count() and tally(), which we are going to see further down. It is also possible to rename the column on the fly: gasoline %&gt;% group_by(country) %&gt;% mutate(freq = n()) ## # A tibble: 342 x 7 ## # Groups: country [18] ## country year lgaspcar lincomep lrpmg lcarpcap freq ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 AUSTRIA 1960 4.17 -6.47 -0.335 -9.77 19 ## 2 AUSTRIA 1961 4.10 -6.43 -0.351 -9.61 19 ## 3 AUSTRIA 1962 4.07 -6.41 -0.380 -9.46 19 ## 4 AUSTRIA 1963 4.06 -6.37 -0.414 -9.34 19 ## 5 AUSTRIA 1964 4.04 -6.32 -0.445 -9.24 19 ## 6 AUSTRIA 1965 4.03 -6.29 -0.497 -9.12 19 ## 7 AUSTRIA 1966 4.05 -6.25 -0.467 -9.02 19 ## 8 AUSTRIA 1967 4.05 -6.23 -0.506 -8.93 19 ## 9 AUSTRIA 1968 4.05 -6.21 -0.522 -8.85 19 ## 10 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 19 ## # ... with 332 more rows It is possible to do any arbitrary operation: gasoline %&gt;% group_by(country) %&gt;% mutate(spam = exp(lgaspcar + lincomep)) ## # A tibble: 342 x 7 ## # Groups: country [18] ## country year lgaspcar lincomep lrpmg lcarpcap spam ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 AUSTRIA 1960 4.17 -6.47 -0.335 -9.77 0.100 ## 2 AUSTRIA 1961 4.10 -6.43 -0.351 -9.61 0.0978 ## 3 AUSTRIA 1962 4.07 -6.41 -0.380 -9.46 0.0969 ## 4 AUSTRIA 1963 4.06 -6.37 -0.414 -9.34 0.0991 ## 5 AUSTRIA 1964 4.04 -6.32 -0.445 -9.24 0.102 ## 6 AUSTRIA 1965 4.03 -6.29 -0.497 -9.12 0.104 ## 7 AUSTRIA 1966 4.05 -6.25 -0.467 -9.02 0.110 ## 8 AUSTRIA 1967 4.05 -6.23 -0.506 -8.93 0.113 ## 9 AUSTRIA 1968 4.05 -6.21 -0.522 -8.85 0.115 ## 10 AUSTRIA 1969 4.05 -6.15 -0.559 -8.79 0.122 ## # ... with 332 more rows transmute() is the same as mutate(), but only returns the created variable: gasoline %&gt;% group_by(country) %&gt;% transmute(spam = exp(lgaspcar + lincomep)) ## # A tibble: 342 x 2 ## # Groups: country [18] ## country spam ## &lt;fct&gt; &lt;dbl&gt; ## 1 AUSTRIA 0.100 ## 2 AUSTRIA 0.0978 ## 3 AUSTRIA 0.0969 ## 4 AUSTRIA 0.0991 ## 5 AUSTRIA 0.102 ## 6 AUSTRIA 0.104 ## 7 AUSTRIA 0.110 ## 8 AUSTRIA 0.113 ## 9 AUSTRIA 0.115 ## 10 AUSTRIA 0.122 ## # ... with 332 more rows 5.3 Reshaping data with tidyr Another important package from the tidyverse that goes hand in hand with dplyr is tidyr. tidyr is the package you need when it’s time to reshape data. The basic functions from tidyr, spread() and gather() make it possible to go from long to wide datasets respectively. library(tidyr) survey_data = tribble( ~id, ~variable, ~value, 1, &quot;var1&quot;, 1, 1, &quot;var2&quot;, 0.2, 2, &quot;var1&quot;, 1.4, 2, &quot;var2&quot;, 1.9, 3, &quot;var1&quot;, 0.1, 3, &quot;var2&quot;, 2.8, 4, &quot;var1&quot;, 1.7, 4, &quot;var2&quot;, 1.9 ) head(survey_data) ## # A tibble: 6 x 3 ## id variable value ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 var1 1 ## 2 1 var2 0.2 ## 3 2 var1 1.4 ## 4 2 var2 1.9 ## 5 3 var1 0.1 ## 6 3 var2 2.8 This above is a long dataset. We can reshape it to be wide using the spread() function: wide_data = survey_data %&gt;% spread(variable, value) head(wide_data) ## # A tibble: 4 x 3 ## id var1 var2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 0.2 ## 2 2 1.4 1.9 ## 3 3 0.1 2.8 ## 4 4 1.7 1.9 This means that we spread the column called “variable”, which will produce one column per category of “variable”. Then we fill in the rows with the data contained in the column “value”. To go from a wide dataset to a long one, we use gather(): long_data = wide_data %&gt;% gather(variable, value, var1, var2) print(long_data) ## # A tibble: 8 x 3 ## id variable value ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 var1 1 ## 2 2 var1 1.4 ## 3 3 var1 0.1 ## 4 4 var1 1.7 ## 5 1 var2 0.2 ## 6 2 var2 1.9 ## 7 3 var2 2.8 ## 8 4 var2 1.9 long_data and survey_data are the same datasets, but in a different order. In the wide_data tibble, we had 3 columns: id, var1 and var2. We want to stack ‘var1’ and ‘var2’ in a new column, that we chose to call “variable”. This is the “key”. For the value, we are using the values contained in var1 and var2. Sometimes using spread() or gather() requires some trial and error. I advise you play around with the examples above to really grasp how these powerful functions work. The last function from tidyr that we are going to discuss is nest(), but we will keep it for later, in the section about so-called list-columns. 5.4 Getting to know factor variables Remember in chapter 3 when I very quickly explained what were factor variables? In this section, we are going to work a little bit with these type of variable. factors are very useful, and the forcats package includes some handy functions to work with them. First, let’s load the forcats package: library(forcats) as an example, we are going to work with the gss_cat dataset that is included in forcats. Let’s load that: data(gss_cat) head(gss_cat) ## # A tibble: 6 x 9 ## year marital age race rincome partyid relig denom tvhours ## &lt;int&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 2000 Never ma… 26 White $8000 to… Ind,near … Protes… Southe… 12 ## 2 2000 Divorced 48 White $8000 to… Not str r… Protes… Baptis… NA ## 3 2000 Widowed 67 White Not appl… Independe… Protes… No den… 2 ## 4 2000 Never ma… 39 White Not appl… Ind,near … Orthod… Not ap… 4 ## 5 2000 Divorced 25 White Not appl… Not str d… None Not ap… 1 ## 6 2000 Married 25 White $20000 -… Strong de… Protes… Southe… NA as you can see, marital, race, rincome and partyid are all factor variables. Let’s take a closer look at marital: str(gss_cat$marital) ## Factor w/ 6 levels &quot;No answer&quot;,&quot;Never married&quot;,..: 2 4 5 2 4 6 2 4 6 6 ... and let’s see rincome: str(gss_cat$rincome) ## Factor w/ 16 levels &quot;No answer&quot;,&quot;Don&#39;t know&quot;,..: 8 8 16 16 16 5 4 9 4 4 ... factor variables have different levels and the forcats package includes functions that allow you to recode, collapse and do all sorts of things on these levels. For example , using forcats::fct_recode() you can recode levels: gss_cat = gss_cat %&gt;% mutate(marital = fct_recode(marital, refuse = &quot;No answer&quot;, never_married = &quot;Never married&quot;, divorced = &quot;Separated&quot;, divorced = &quot;Divorced&quot;, widowed = &quot;Widowed&quot;, married = &quot;Married&quot;)) gss_cat %&gt;% tabyl(marital) ## marital n percent ## refuse 17 0.0007913234 ## never_married 5416 0.2521063166 ## divorced 4126 0.1920588372 ## widowed 1807 0.0841130196 ## married 10117 0.4709305032 Using fct_recode(), I was able to recode the levels and collapse Separated and Divorced to a single category called divorced. As you can see, refuse and widowed are less than 10%, so maybe you’d want to lump these categories together: gss_cat = gss_cat %&gt;% mutate(marital = fct_lump(marital, prop = 0.10, other_level = &quot;other&quot;)) gss_cat %&gt;% tabyl(marital) ## marital n percent ## never_married 5416 0.25210632 ## divorced 4126 0.19205884 ## married 10117 0.47093050 ## other 1824 0.08490434 I suggest you read forcats’ help page and discover the other functions it contains. 5.5 Scoped {tidyverse} verbs 5.5.1 filter_() 5.5.2 select_() 5.5.3 group_by_() 5.5.4 summarise_() 5.5.5 mutate_() 5.6 Working with a list of datasets 5.6.1 Getting to know map() This is our first encouter with a typical functional programming function, map(). Let’s read the list of datasets from the previous chapter: paths = Sys.glob(&quot;datasets/unemployment/*.csv&quot;) all_datasets = import_list(paths) str(all_datasets) ## List of 4 ## $ unemp_2013:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of which: Wage-earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of which: Non-wage-earners: int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ Unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ Active population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## ..$ Year : int [1:118] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ unemp_2014:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of which: Wage-earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of which: Non-wage-earners: int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ Unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ Active population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## ..$ Year : int [1:118] 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ unemp_2015:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of which: Wage-earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of which: Non-wage-earners: int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ Active population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## ..$ Year : int [1:118] 2015 2015 2015 2015 2015 2015 2015 2015 2015 2015 ... ## $ unemp_2016:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of which: Wage-earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of which: Non-wage-earners: int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ Active population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.15 5.04 4.84 3.01 4.3 ... ## ..$ Year : int [1:118] 2016 2016 2016 2016 2016 2016 2016 2016 2016 2016 ... For working with lists, another package from the tidyverse is very useful, and that would be purrr. purrr has functions to work with lists, and we are going to focus on two of them, map() and reduce(). map()… maps a function to each element of a list. reduce() is a bit more complicated so we’ll leave that for later. map() and reduce() are also called functionals; functions that use functions as arguments. The first thing we are going to do is use a function to clean the names of the datasets. These names are not very easy to work with; there are spaces, and it would be better if the names of the columns would be all lowercase. For this we are going to use the function clean_names() from the janitor package. For a single dataset, I would write this: library(janitor) one_dataset = one_dataset %&gt;% clean_names() and I would get a dataset with column names in lowercase and spaces replaced by _ (and other corrections). How can I apply, or map, this function to each dataset in the list? To do this I need to use purrr::map(): library(purrr) all_datasets = all_datasets %&gt;% map(clean_names) all_datasets %&gt;% glimpse() ## List of 4 ## $ unemp_2013:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of_which_wage_earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of_which_non_wage_earners : int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ active_population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## ..$ year : int [1:118] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ unemp_2014:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of_which_wage_earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of_which_non_wage_earners : int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ active_population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## ..$ year : int [1:118] 2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ... ## $ unemp_2015:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of_which_wage_earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of_which_non_wage_earners : int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ active_population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## ..$ year : int [1:118] 2015 2015 2015 2015 2015 2015 2015 2015 2015 2015 ... ## $ unemp_2016:&#39;data.frame&#39;: 118 obs. of 8 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of_which_wage_earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of_which_non_wage_earners : int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ active_population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.15 5.04 4.84 3.01 4.3 ... ## ..$ year : int [1:118] 2016 2016 2016 2016 2016 2016 2016 2016 2016 2016 ... So now, what if I want to know, for each dataset, which communes have an unemployment rate that is less than, say, 3%? For a single dataset I would do something like this: one_dataset %&gt;% filter(unemployment_rate_in_percent &lt; 3) But for a list of datasets, map() is needed (and as you will see, that is not all that is needed): all_datasets %&gt;% map(~filter(., unemployment_rate_in_percent &lt; 3)) ## $unemp_2013 ## commune total_employed_population of_which_wage_earners ## 1 Garnich 844 750 ## 2 Leudelange 1064 937 ## 3 Bech 526 463 ## of_which_non_wage_earners unemployed active_population ## 1 94 25 869 ## 2 127 32 1096 ## 3 63 16 542 ## unemployment_rate_in_percent year ## 1 2.876870 2013 ## 2 2.919708 2013 ## 3 2.952030 2013 ## ## $unemp_2014 ## commune total_employed_population of_which_wage_earners ## 1 Garnich 845 757 ## 2 Leudelange 1102 965 ## 3 Bech 543 476 ## 4 Flaxweiler 879 789 ## of_which_non_wage_earners unemployed active_population ## 1 88 19 864 ## 2 137 34 1136 ## 3 67 15 558 ## 4 90 27 906 ## unemployment_rate_in_percent year ## 1 2.199074 2014 ## 2 2.992958 2014 ## 3 2.688172 2014 ## 4 2.980132 2014 ## ## $unemp_2015 ## commune total_employed_population of_which_wage_earners ## 1 Bech 520 450 ## 2 Bous 750 680 ## of_which_non_wage_earners unemployed active_population ## 1 70 14 534 ## 2 70 22 772 ## unemployment_rate_in_percent year ## 1 2.621723 2015 ## 2 2.849741 2015 ## ## $unemp_2016 ## commune total_employed_population of_which_wage_earners ## 1 Reckange-sur-Mess 980 850 ## 2 Bech 520 450 ## 3 Betzdorf 1500 1350 ## 4 Flaxweiler 910 820 ## of_which_non_wage_earners unemployed active_population ## 1 130 30 1010 ## 2 70 11 531 ## 3 150 45 1545 ## 4 90 24 934 ## unemployment_rate_in_percent year ## 1 2.970297 2016 ## 2 2.071563 2016 ## 3 2.912621 2016 ## 4 2.569593 2016 I know what you’re thinking… what the hell?. Let me explain: map() needs a function to map to each element of the list. all_datasets is the list to which I want to map the function. But what function? filter() is the function I need, so why doesn’t: all_datasets %&gt;% map(filter(unemployment_rate_in_percent &lt; 3)) work? This is a bit complicated, and has to do with what is called environments. If you try to run the code above, you will get this error message: Error in filter(unemployment_rate_in_percent &lt; 3) : object &#39;unemployment_rate_in_percent&#39; not found I won’t go into details, but by writing ~filter(., unemployment_rate_in_percent &lt; 3), which is a formula (~ is the symbol to define formulas, more on this in the later chapters), map() converts it to a function that it can use. If you want to know more about this, you can read it in Advanced R by Hadley Wickham, but it is an advanced topic. 5.6.2 Getting to know reduce() Using map() we now know how to apply a function to each dataset of a list. But maybe it would be easier to merge all the datasets first, and then manipulate them? Before that though, I am going to teach you how to use purrr::reduce(), another very powerful function that works on lists. This is a function that you can find in other programming languages, but sometimes it is called fold. I think that the following example illustrates the power of reduce() well: numbers = seq(1, 5) # Create a vector with the numbers 1 to 5 reduce(numbers, `+`, .init = 0) ## [1] 15 reduce() takes a function as an argument, here the function +1 and then does the following computation: 0 + numbers[1] + numbers[2] + numbers[3]... It applies the user supplied function successively but has to start with something, so we give it the argument init also. This argument is actually optional, but I show it here because in some cases it might be useful to start the computations at another value than 0.reduce() generalizes functions that only take two arguments. If you were to write a function that returns the minimum between two numbers: my_min = function(a, b){ if(a &lt; b){ return(a) } else { return(b) } } You could use reduce() to get the minimum of a list of numbers: numbers2 = c(3, 1, -8, 9) reduce(numbers2, my_min) ## [1] -8 As long as you provide a function and a list of elements to reduce(), you will get a single output. So how could reduce() help us with merging all the datasets that are in the list? dplyr comes with a lot of function to merge two datasets. Remember that I said before that reduce() allows you to generalize a function of two arguments? Let’s try it with our list of datasets: unemp_lux = reduce(all_datasets, full_join) ## Joining, by = c(&quot;commune&quot;, &quot;total_employed_population&quot;, &quot;of_which_wage_earners&quot;, &quot;of_which_non_wage_earners&quot;, &quot;unemployed&quot;, &quot;active_population&quot;, &quot;unemployment_rate_in_percent&quot;, &quot;year&quot;) ## Joining, by = c(&quot;commune&quot;, &quot;total_employed_population&quot;, &quot;of_which_wage_earners&quot;, &quot;of_which_non_wage_earners&quot;, &quot;unemployed&quot;, &quot;active_population&quot;, &quot;unemployment_rate_in_percent&quot;, &quot;year&quot;) ## Joining, by = c(&quot;commune&quot;, &quot;total_employed_population&quot;, &quot;of_which_wage_earners&quot;, &quot;of_which_non_wage_earners&quot;, &quot;unemployed&quot;, &quot;active_population&quot;, &quot;unemployment_rate_in_percent&quot;, &quot;year&quot;) glimpse(unemp_lux) ## Observations: 472 ## Variables: 8 ## $ commune &lt;chr&gt; &quot;Grand-Duche de Luxembourg&quot;, &quot;Can... ## $ total_employed_population &lt;int&gt; 223407, 17802, 1703, 844, 1431, 4... ## $ of_which_wage_earners &lt;int&gt; 203535, 15993, 1535, 750, 1315, 3... ## $ of_which_non_wage_earners &lt;int&gt; 19872, 1809, 168, 94, 116, 294, 2... ## $ unemployed &lt;int&gt; 19287, 1071, 114, 25, 74, 261, 98... ## $ active_population &lt;int&gt; 242694, 18873, 1817, 869, 1505, 4... ## $ unemployment_rate_in_percent &lt;dbl&gt; 7.947044, 5.674773, 6.274078, 2.8... ## $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 201... full_join() is one of the dplyr function that merges data. There are others that might be useful depending on the kind of join operation you need. Let’s write this data to disk as we’re going to keep using it for the next chapters: export(unemp_lux, &quot;datasets/unemp_lux.csv&quot;) 5.7 List-columns To learn about list-columns, let’s first focus on a single character of the starwars dataset: data(starwars) starwars %&gt;% filter(name == &quot;Luke Skywalker&quot;) %&gt;% glimpse() ## Observations: 1 ## Variables: 13 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot; ## $ height &lt;int&gt; 172 ## $ mass &lt;dbl&gt; 77 ## $ hair_color &lt;chr&gt; &quot;blond&quot; ## $ skin_color &lt;chr&gt; &quot;fair&quot; ## $ eye_color &lt;chr&gt; &quot;blue&quot; ## $ birth_year &lt;dbl&gt; 19 ## $ gender &lt;chr&gt; &quot;male&quot; ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot; ## $ species &lt;chr&gt; &quot;Human&quot; ## $ films &lt;list&gt; [&lt;&quot;Revenge of the Sith&quot;, &quot;Return of the Jedi&quot;, &quot;Th... ## $ vehicles &lt;list&gt; [&lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;] ## $ starships &lt;list&gt; [&lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;] We see that the columns films, vehicles and starships are all lists, and in the case of films, it lists all the films where Luke Skywalker has appeared. What if you want to take a closer look at this list? starwars %&gt;% filter(name == &quot;Luke Skywalker&quot;) %&gt;% pull(films) ## [[1]] ## [1] &quot;Revenge of the Sith&quot; &quot;Return of the Jedi&quot; ## [3] &quot;The Empire Strikes Back&quot; &quot;A New Hope&quot; ## [5] &quot;The Force Awakens&quot; pull() is a dplyr function that extract (pulls) the column you’re interested in. It is quite useful when you want to inspect a column. Suppose we want to create a categorical variable which counts the number of movies in which the characters have appeared. For this we need to compute the length of the list, or count the number of elements this list has. Let’s try with length() a base R function: starwars %&gt;% filter(name == &quot;Luke Skywalker&quot;) %&gt;% pull(films) %&gt;% length() ## [1] 1 This might be surprising at first, because we know that Luke Skywalker has appeared in more than 1 movie… the problem here is that for each individual, films is a list, whose single element is a vector of characters. This means that length(films) computes the length of the list, which is one, and not the length of the vector contained in the list! How can we get the length of the vector of characters contained in the list and for each character? For this we need to use dplyr::rowwise() and remove the filter() function and use mutate() to add this column to the dataset: starwars = starwars %&gt;% rowwise() %&gt;% mutate(n_films = length(films)) dplyr::rowwise() is useful when working with list-columns: columns that have lists as elements. Let’s take a look at the characters and the number of films they have appeared in: starwars %&gt;% select(name, n_films) ## Source: local data frame [87 x 2] ## Groups: &lt;by row&gt; ## ## # A tibble: 87 x 2 ## name n_films ## &lt;chr&gt; &lt;int&gt; ## 1 Luke Skywalker 5 ## 2 C-3PO 6 ## 3 R2-D2 7 ## 4 Darth Vader 4 ## 5 Leia Organa 5 ## 6 Owen Lars 3 ## 7 Beru Whitesun lars 3 ## 8 R5-D4 1 ## 9 Biggs Darklighter 1 ## 10 Obi-Wan Kenobi 6 ## # ... with 77 more rows Now we can create a factor variable that groups characters by asking whether they appeared only in 1 movie, or more: starwars = starwars %&gt;% mutate(more_1 = case_when(n_films == 1 ~ &quot;Exactly one movie&quot;, n_films != 1 ~ &quot;More than 1 movie&quot;)) case_when() is a dplyr function that works similarly to the standard if..else.. construct of many programming languages (R also has this, we are going to learn about it in later chapters). You can also create list columns with your own datasets, by using tidyr::nest(). Remember the fake survey_data I created to illustrate spread() and gather()? Let’s go back to that dataset again: print(survey_data) ## # A tibble: 8 x 3 ## id variable value ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 var1 1 ## 2 1 var2 0.2 ## 3 2 var1 1.4 ## 4 2 var2 1.9 ## 5 3 var1 0.1 ## 6 3 var2 2.8 ## 7 4 var1 1.7 ## 8 4 var2 1.9 nested_data = survey_data %&gt;% nest(variable, value) print(nested_data) ## # A tibble: 4 x 2 ## id data ## &lt;dbl&gt; &lt;list&gt; ## 1 1 &lt;tibble [2 × 2]&gt; ## 2 2 &lt;tibble [2 × 2]&gt; ## 3 3 &lt;tibble [2 × 2]&gt; ## 4 4 &lt;tibble [2 × 2]&gt; This creates a new tibble, with columns id and data. data is a list-column that contains tibbles; each tibble is the variable and value for each individual: nested_data %&gt;% filter(id == &quot;1&quot;) %&gt;% pull(data) ## [[1]] ## # A tibble: 2 x 2 ## variable value ## &lt;chr&gt; &lt;dbl&gt; ## 1 var1 1 ## 2 var2 0.2 As you can see, for individual 1, the column data contains a 2x2 tibble with columns variable and value. You might be wondering why this is useful, because this seems to introduce an unnecessary layer of complexity. The usefulness of list-columns will become apparent in the next chapters, where we are going to learn how to repeat actions over, say, individuals. 5.8 Exercises Exercise 1 Load the LaborSupply dataset from the Ecdat package and answer the following questions: Compute the average annual hours worked by year (plus standard deviation) What age group worked the most hours in the year 1982? Create a variable, n_years that equals the number of years an individual stays in the panel. Is the panel balanced? Which are the individuals that do not have any kids during the whole period? Create a variable, no_kids, that flags these individuals (1 = no kids, 0 = kids) Using the no_kids variable from before compute the average wage, standard deviation and number of observations in each group for the year 1980 (no kids group vs kids group). Create the lagged logarithm of hours worked and wages. Remember that this is a panel. Exercise 2 What does the following code do? Copy and paste it in an R interpreter to find out! LaborSupply %&gt;% group_by(id) %&gt;% mutate_at(vars(starts_with(&quot;l&quot;)), funs(lag, lead)) mutate_at() is a scoped version of mutate() which allows you to specify a number of columns and functions in one go. This also exists for summarise(). Using summarise_at(), compute the mean, standard deviation and number of individuals of lnhr and lnwg for each individual. Exercise 3 In the dataset folder you downloaded at the beginning of the chapter, there is a folder called “unemployment”. I used the data in the section about working with lists of datasets. Using rio::import_list(), read the 4 datasets into R. Using map(), map the janitor::clean_names() function to each dataset (just like in the example in the section on working with lists of datasets). Then, still with map() and mutate() convert all commune names in the commune column with the function tolower(), in a new column called lcommune. This is not an easy exercise; so here are some hints: Remember that all_datasets is a list of datasets. Which function do you use when you want to map a function to each element of a list? Each element of all_datasets are data.frame objects. Which function do you use to add a column to a data.frame? What symbol can you use to access a column of a data.frame? This is simply the + operator you’re used to. Try this out: `+`(1, 5) and you’ll see + is a function like any other. You just have to write backticks around the plus symbol to make it work.↩ "]
]
